<!DOCTYPE html>

<html>
  <head>
    <title>N-tris</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=600px, user-scalable=no" /> <!-- disabled in iOS 10+ -->    <style>
      body {
          background:#aaa;
          color:#000;
          font-family:sans-serif;
      }

      div#content {
          margin: 0px auto;
      }

      h1 {
          margin:10px;
          font-size:3em;
      }

      /*Font Faces*/
      @font-face {
          font-family: "Segmented";
          src: url('fonts/Segment7Standard.otf');
      }

      @font-face {
          font-family: "SegmentedAlpha";
          src: url('fonts/Digital7Regular.otf');
      }

      g.button{ 
          touch-action: manipulation;
      }

      .mobile { display:none; }

      @media (max-width: 991px) {
          .mobile {
              display:block !important;
              touch-action: manipulation;
          }
      }
    </style>
  </head>

  <body onload="tetris_instance.firstRun();" onresize="tetris_instance.resizeGame()">

    <div id="content" style="margin: 0 auto; width:512px;">
      <canvas id="canvas" width="512" height="512" onclick="tetris_instance.start();" style="border:1px solid black; touch-action: manipulation"></canvas><br>

      <div class="mobile">
        <svg width="100%"
             height="100%"
             viewBox="80 50 1000 600"
             version="1.1"
             xmlns="http://www.w3.org/2000/svg"
             xmlns:xlink="http://www.w3.org/1999/xlink"
             xml:space="preserve"
             xmlns:serif="http://www.serif.com/"
             style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">

          <!-- Start/Select -->
          <g class="button" onclick="tetris_instance.toggleGhostMode();" transform="matrix(1,0,0,1,-50,0)">
            <path d="M602.032,562.235C602.032,550.187 592.25,540.405 580.202,540.405L412.402,540.405C400.354,540.405 390.572,550.187 390.572,562.235C390.572,574.284 400.354,584.066 412.402,584.066L580.202,584.066C592.25,584.066 602.032,574.284 602.032,562.235Z" style="fill:rgb(44,44,44);"/>
            <path d="M602.032,562.235C602.032,550.187 592.25,540.405 580.202,540.405L412.402,540.405C400.354,540.405 390.572,550.187 390.572,562.235C390.572,574.284 400.354,584.066 412.402,584.066L580.202,584.066C592.25,584.066 602.032,574.284 602.032,562.235Z" style="fill:rgb(27,27,27);"/>
            <path d="M591.167,562.235C591.167,555.826 585.963,550.622 579.554,550.622L413.05,550.622C406.641,550.622 401.437,555.826 401.437,562.235C401.437,568.645 406.641,573.849 413.05,573.849L579.554,573.849C585.963,573.849 591.167,568.645 591.167,562.235Z" style="fill:rgb(39,39,39);"/>
          </g>
          <g class="button" onclick="tetris_instance.start(focus=false);"  transform="matrix(1,0,0,1,-50,0)">
            <path d="M889.428,562.235C889.428,550.187 879.646,540.405 867.598,540.405L699.798,540.405C687.75,540.405 677.968,550.187 677.968,562.235C677.968,574.284 687.75,584.066 699.798,584.066L867.598,584.066C879.646,584.066 889.428,574.284 889.428,562.235Z" style="fill:rgb(44,44,44);"/>
            <path d="M889.428,562.235C889.428,550.187 879.646,540.405 867.598,540.405L699.798,540.405C687.75,540.405 677.968,550.187 677.968,562.235C677.968,574.284 687.75,584.066 699.798,584.066L867.598,584.066C879.646,584.066 889.428,574.284 889.428,562.235Z" style="fill:rgb(27,27,27);"/>
            <path d="M878.563,562.235C878.563,555.826 873.359,550.622 866.95,550.622L700.446,550.622C694.037,550.622 688.833,555.826 688.833,562.235C688.833,568.645 694.037,573.849 700.446,573.849L866.95,573.849C873.359,573.849 878.563,568.645 878.563,562.235Z" style="fill:rgb(39,39,39);"/>
          </g>

          <!-- D-Pad -->
          <g>
            <path d="M342.959,109.763C359.714,109.764 373.316,123.366 373.316,140.119L373.316,220.016L453.212,220.016C469.966,220.016 483.568,233.618 483.568,250.372L483.568,311.084C483.568,327.838 469.966,341.441 453.212,341.441L373.316,341.441L373.316,421.337C373.316,438.091 359.713,451.693 342.959,451.693L282.247,451.693C265.493,451.693 251.891,438.091 251.891,421.337L251.891,341.441L171.994,341.441C155.24,341.441 141.638,327.838 141.638,311.084L141.638,250.372C141.638,233.618 155.24,220.016 171.994,220.016L251.891,220.016L251.891,140.119C251.891,123.366 265.493,109.764 282.247,109.763L342.959,109.763Z"/>
            <path d="M339.31,117.685C354.05,117.685 366.016,129.652 366.016,144.391L366.016,227.315L448.94,227.315C463.68,227.316 475.647,239.282 475.647,254.022L475.647,307.435C475.647,322.175 463.68,334.141 448.94,334.141L366.016,334.141L366.016,417.065C366.016,431.805 354.05,443.772 339.31,443.772L285.897,443.772C271.157,443.772 259.19,431.805 259.19,417.065L259.19,334.141L176.266,334.141C161.527,334.141 149.56,322.175 149.56,307.435L149.56,254.022C149.56,239.282 161.526,227.316 176.266,227.315L259.19,227.315L259.19,144.391C259.19,129.652 271.157,117.685 285.897,117.685L339.31,117.685Z" style="fill:rgb(26,26,26);"/>
            <ellipse cx="312.603" cy="280.728" rx="33.985" ry="34.549" style="fill:rgb(51,51,51);"/>
            <rect x="265.847" y="180.812" width="93.513" height="21.932" style="fill:rgb(51,51,51);"/>
            <rect x="265.847" y="150.812" width="93.513" height="21.932" style="fill:rgb(51,51,51);"/>
            <rect x="265.847" y="388.068" width="93.513" height="21.932" style="fill:rgb(51,51,51);"/>
            <rect x="265.847" y="358.068" width="93.513" height="21.932" style="fill:rgb(51,51,51);"/>
            <path d="M412.197,327.162L412.197,233.649L390.265,233.649L390.265,327.162L412.197,327.162Z" style="fill:rgb(51,51,51);"/>
            <path d="M442.197,327.162L442.197,233.649L420.265,233.649L420.265,327.162L442.197,327.162Z" style="fill:rgb(51,51,51);"/>
            <path d="M204.941,327.162L204.941,233.649L183.009,233.649L183.009,327.162L204.941,327.162Z" style="fill:rgb(51,51,51);"/>
            <path d="M234.941,327.162L234.941,233.649L213.009,233.649L213.009,327.162L234.941,327.162Z" style="fill:rgb(51,51,51);"/>
          </g>

          <!-- Buttons A/B -->
          <g class="button" onclick="tetris_instance.move(tetris_instance.direction.ccw);">
            <circle cx="724.723" cy="349.044" r="84.723" style="fill:rgb(171,0,0);"/>
            <circle cx="724.723" cy="349.044" r="76.8" style="fill:rgb(210,7,7);"/>
          </g>
          <g class="button" onclick="tetris_instance.move(tetris_instance.direction.cw);">
            <circle cx="940.009" cy="212.413" r="84.723" style="fill:rgb(171,0,0);"/>
            <circle cx="940.009" cy="212.413" r="76.8" style="fill:rgb(210,7,7);"/>
          </g>

          <!-- D-Pad Sensor Shapes -->
          <g class="button" onclick="tetris_instance.move(tetris_instance.direction.ccw);">
            <path d="M312.603,280.728L483.568,109.763L312.603,58.765L141.638,109.763L312.603,280.728Z" style="fill:rgba(255,0,0,0);"/>
          </g>
          <g class="button" onclick="tetris_instance.move(tetris_instance.direction.right);">
            <path d="M312.603,280.728L483.568,451.693L534.566,280.728L483.568,109.763L312.603,280.728Z" style="fill:rgba(17,255,0,0);"/>
          </g>
          <g class="button" onclick="tetris_instance.move(tetris_instance.direction.down);">
            <path d="M312.603,280.728L141.638,451.693L312.603,502.691L483.568,451.693L312.603,280.728Z" style="fill:rgba(0,255,239,0);"/>
          </g>
          <g class="button" onclick="tetris_instance.move(tetris_instance.direction.left);">
            <path d="M312.603,280.728L141.638,109.763L90.64,280.728L141.638,451.693L312.603,280.728Z" style="fill:rgba(0,4,255,0);"/>
          </g>
        </svg>
      </div>
    </div>

    <script>
      // Comment

      class tetris {
          constructor(canvas){
              this.canvas = canvas;
              this.ctx = canvas.getContext("2d");

              // Game dimensions
              this.dimension = {
                  game_width           : 10,
                  game_height          : 20,
                  square_size          : 20,
                  square_min_size      : 5,  // Minimum size
                  block_chisled_ratio  : .25,
                  block_outline_ratio  : .1,
                  block_min_edge_size  : 1,
                  starting_square_size : 20, // Starting size for scaling fonts/graphics
                  top_buffer           : 5,  // Space for spawning new blocks
                  left_buffer          : 7,  // Space for next block
                  right_buffer         : 7,  // Space for next block
                  game_border          : 1,  // Border width around play area
                  em                   : 1,  // Font scaling constant
              }

              // Game variables
              this.state = {
                  game_array      : [],                   // Play field
                  game_active     : false,
                  game_paused     : null,
                  game_overlay    : null,
                  lines           : 0,
                  level           : 0,
                  score           : 0,
                  block_upcoming  : [],                   // Next chosen blocks
                  block_history   : [],                   // History of blocks chosen
                  block_position  : [null, null, null, null], // Block x, y, rotation, points
                  timer           : null,                 // Main loop timer
                  animation_timer : [null, null, null],   // Timer for animations
                  blockset        : [],
                  imacheater      : false,
              };

              // Settings/Toggles
              this.settings = {
                  useExtraPieces : true,
                  showGhostBlock : true,
                  debug          : false,
                  cheat          : false,
              };

              // Definitions
              this.direction = {
                  up    : 1,
                  right : 2,
                  down  : 3,
                  left  : 4,
                  drop  : 5,
                  cw    : 6,
                  ccw   : 7
              };

              // Key Codes
              this.key = {
                  space       : 32,
                  left_arrow  : 37,
                  up_arrow    : 38,
                  right_arrow : 39,
                  down_arrow  : 40,
                  c           : 67,
                  i           : 73,
                  j           : 74,
                  k           : 75,
                  l           : 76,
                  n           : 78,
                  e           : 69,
                  o           : 79,
                  g           : 71,
                  p           : 80,
                  d           : 68,
                  q           : 81,
                  s           : 83,
                  plus        : 61,
                  minus       : 173,
              };

              this.EMPTY  = -2;

              this.colors = {
                  background : "#222222",
                  black      : "#000000",
                  red        : "#CC0000",
                  amber      : "#CCBB00",
                  green      : "#00CC00",
                  light_grey : "#CCCCCC",
                  white      : "#FFFFFF",
              };

              this.level_colors = [
                  "#888888",
                  "#FF0000",
                  "#FFFF00",
                  "#00FF00",
                  "#00FFFF",
                  "#0000FF",
                  "#FF00FF",
              ];

              this.overlays = {
                  firstrun : [{color  : "white",
                               size   : 28,
                               font   : "SegmentedAlpha",
                               align  : "center",
                               y      : 170,
                               x      : null,
                               string : "Click to start!"}],
                  paused   : [{color  : "white",
                               size   : 48,
                               font   : "SegmentedAlpha",
                               align  : "center",
                               y      : 170,
                               x      : null,
                               string : "PAUSED"},
                              {color  : "white",
                               size   : 20,
                               font   : "Arial",
                               align  : "center",
                               y      : 200,
                               x      : null,
                               string : "Click to resume."}],
                  gameover : [{color  : "white",
                               size   : 40,
                               font   : "SegmentedAlpha",
                               align  : "center",
                               y      : 170,
                               x      : null,
                               string : "GAME OVER"},
                              {color  : "white",
                               size   : 20,
                               font   : "Arial",
                               align  : "center",
                               y      : 200,
                               x      : null,
                               string : "Click to play again!"}],
              }

              this.rules = {
                  startingBlocks     : ['I', 'L', 'J', 'T'],
                  tetrominoes        : ['I', 'L', 'J', 'T', 'S', 'Z', 'O'],
                  line_scores        : [null, 40, 100, 300, 1200, 2600], // score value per lines cleared
                  base_speed         : 890,
                  speedup_multiplier : .86,
                  max_speed          : 50,
              };

              this.block_defs = {
                  // Tetrominoes
                  I : {
                      shape : [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]],
                      rotations : 2,
                      color : { r:0xFF, g:0x00, b:0x00 }, // Red
                  },
                  Z : {
                      shape : [[1,1,0], [0,1,1], [0,0,0]],
                      rotations : 2,
                      color : { r:0xFF, g:0x92, b:0x00 }, // Orange
                  },
                  J : {
                      shape : [[0,0,0], [1,1,1], [0,0,1]],
                      rotations : 4,
                      color : { r:0xDB, g:0xB6, b:0x00 }, // Yellow
                  },
                  T : {
                      shape : [[0,0,0], [1,1,1], [0,1,0]],
                      rotations : 4,
                      color : { r:0x49, g:0xB6, b:0x00 }, // Green
                  },
                  S : {
                      shape : [[0,1,1], [1,1,0], [0,0,0]],
                      rotations : 2,
                      color : { r:0x00, g:0xB6, b:0xAA }, // Cyan
                  },
                  O: {
                      shape : [[0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0]],
                      rotations : 1,
                      color : { r:0x00, g:0x49, b:0xFF }, // Blue
                  },
                  L : {
                      shape : [[0,0,0], [1,1,1], [1,0,0]],
                      rotations : 4,
                      color : { r:0xDB, g:0x00, b:0xFF }, // Purple
                  },

                  // Pentominoes
                  LongJ : {
                      shape : [[0,0,0,0], [1,0,0,0], [1,1,1,1], [0,0,0,0]],
                      rotations : 4,
                      color : { r:0xcc, g:0x83, b:0x00 }, // Red-Orange
                  },
                  LongL : {
                      shape : [[0,0,0,0], [0,0,0,1], [1,1,1,1], [0,0,0,0]],
                      rotations : 4,
                      color : { r:0xa0, g:0x00, b:0xff }, // Light BLue
                  },
                  IL : {
                      shape : [[0,0,0,0], [0,0,1,0], [1,1,1,1], [0,0,0,0]],
                      rotations : 4,
                      color : { r:0xff, g:0xbb, b:0x00 }, // Orange Yellow
                  },
                  JI : {
                      shape : [[0,0,0,0], [0,1,0,0], [1,1,1,1], [0,0,0,0]],
                      rotations : 4,
                      color : { r:0x98, g:0x68, b:0x08 }, // Yellow Green
                  },
                  BigS : {
                      shape : [[1,0,0], [1,1,1], [0,0,1]],
                      rotations : 4,
                      color : { r:0x00, g:0xbb, b:0x88 }, // Teal
                  },
                  BigZ : {
                      shape : [[0,0,1], [1,1,1], [1,0,0]],
                      rotations : 4,
                      color : { r:0x00, g:0xbd, b:0xff }, // Cyan-light blue
                  },
                  JT : {
                      shape : [[0,1,0], [1,1,1], [0,0,1]],
                      rotations : 4,
                      color : { r:0x00, g:0x91, b:0xff }, // Lighter Blue
                  },
                  TL : {
                      shape : [[0,1,0], [1,1,1], [1,0,0]],
                      rotations : 4,
                      color : { r:0xff, g:0x00, b:0x83 }, // Dark Orange
                  },
                  LongS : {
                      shape : [[0,0,0,0], [0,0,1,1], [1,1,1,0], [0,0,0,0]],
                      rotations : 4,
                      color : { r:0x00, g:0x80, b:0x80 }, // Purple
                  },
                  LongZ : {
                      shape : [[0,0,0,0], [1,1,0,0], [0,1,1,1], [0,0,0,0]],
                      rotations : 4,
                      color : { r:0xff, g:0x57, b:0x00 }, // Fuscia
                  },
                  P : {
                      shape : [[0,0,0], [1,1,0], [1,1,1]],
                      rotations : 4,
                      color : { r:0x4c, g:0x00, b:0x99 }, // Brown
                  },
                  b : {
                      shape : [[0,0,0], [0,1,1], [1,1,1]],
                      rotations : 4,
                      color : { r:0x6B, g:0x49, b:0x04 }, // Lime
                  },
                  BigL : {
                      shape : [[1,0,0], [1,0,0], [1,1,1]],
                      rotations : 4,
                      color : { r:0x5C, g:0x5C, b:0x5C }, // Dark Grey
                  },
                  W : {
                      shape : [[0,0,1], [0,1,1], [1,1,0]],
                      rotations : 4,
                      color : { r:0x00, g:0x00, b:0x99 }, // Tan
                  },
                  Plus : {
                      shape : [[0,1,0], [1,1,1], [0,1,0]],
                      rotations : 1,
                      color : { r:0xa0, g:0xff, b:0x00 }, // Dark Cyan
                  },
                  U : {
                      shape : [[0,0,0], [1,0,1], [1,1,1]],
                      rotations : 4,
                      color : { r:0xAA, g:0xDD, b:0x77 }, // Light Grey
                  },
                  LongI : {
                      shape : [[0,0,0,0,0], [0,0,0,0,0], [1,1,1,1,1], [0,0,0,0,0], [0,0,0,0,0]],
                      rotations : 2,
                      color : { r:0x99, g:0x00, b:0x00 }, // Dark Green
                  },
                  BigT : {
                      shape : [[0,1,0], [0,1,0], [1,1,1]],
                      rotations : 4,
                      color : { r:0x00, g:0x66, b:0x00 }, // Light Green
                  },

                  /*
                  Ethan : {
                      shape : [[1,0,1,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]],
                      rotations : 4,
                      color : { r:0xdd, g:0xdd, b:0xdd }, // Dark Green
                      },
                  */

                  // Triominoes
                  SmallL : {
                      shape : [[0,1], [1,1]],
                      rotations : 4,
                      color : { r:0xC0, g:0xC0, b:0xC0 }, // Pink
                  },
                  SmallI : {
                      shape : [[0,0,0], [1,1,1], [0,0,0]],
                      rotations : 2,
                      color : { r:0xA1, g:0x12, b:0x12 }, // Dark Red

                  },

                  // Diominoe
                  TinyI : {
                      shape : [[0,0], [1,1]],
                      rotations : 2,
                      color : { r:0xFF, g:0x66, b:0xB2 }, // Dark Blue

                  },

                  // Monominoe
                  Dot : {
                      shape : [[1]],
                      rotations : 1,
                      color : { r:0xDA, g:0xBB, b:0x7E }, // Dark Purple
                  },
              };
          }

          isGameOver() {
              for (var y=0; y<5; y++){
                  for (var x=0; x<this.state.game_array[y].length; x++){
                      if (this.state.game_array[y][x] != this.EMPTY){
                          return true;
                      }
                  }
              }
              return false;
          }

          clearAndShift(l){
              for (var i=l.length-1; i>=0; i--){
                  var y = l[i];
                  for (var y2=y; y2>=1; y2--){
                      for (var x=0; x<this.dimension.game_width; x++){
                          this.state.game_array[y2][x] = this.state.game_array[y2-1][x];
                      }
                  }
              }
          }

          animateLineClear(l, n){
              this.clearAnimationTimer(1)

              if (n > 0) {
                  let clearLineBlock = { shape : [[1,2,1,2,1,2,1,2,1,2]],
                                     color : [{r:0xff,g:0,b:0}, {r:0,g:0xff,b:0}, {r:0,g:0,b:0xff}][ n%3 ]
                                   }
                  if (n < 8)
                      clearLineBlock.shape = [[1, 2, 1, 2,-2,-2, 1, 2, 1, 2]]
                  if (n < 6)
                      clearLineBlock.shape = [[1, 2, 1,-2,-2,-2,-2, 2, 1, 2]]
                  if (n < 4)
                      clearLineBlock.shape = [[1, 2,-2,-2,-2,-2,-2,-2, 1, 2]]
                  if (n < 2)
                      clearLineBlock.shape = [[1,-2,-2,-2,-2,-2,-2,-2,-2, 2]]
                  for (var i=0; i<l.length; i++){
                      this.drawBlock(this.ctx,
                                     clearLineBlock,
                                     this.dimension.left_buffer + this.dimension.game_border,
                                     l[i],
                                     0)
                  }
                  this.state.animation_timer[1] = setTimeout(() => this.animateLineClear(l, n-1), 20);
              } else {
                  this.clearAndShift(l);
                  // Check if game over because we have a conflict with checking in main loop and animations
                  if (this.isGameOver() == true && lines_cleared == 0){
                      this.endGame();
                  }
              }
          }

          lookForLines(){
              var lines_cleared = [];
              for (var y=this.state.game_array.length-1; y>=this.dimension.top_buffer; y--){
                  // Look at line
                  var lineFull = true;
                  for (var x=0; x<this.dimension.game_width; x++){
                      if (this.state.game_array[y][x] == this.EMPTY){
                          lineFull = false;
                          break;
                      }
                  }

                  // If full lines exist, start animation
                  if (lineFull == true){
                      lines_cleared.push(y);
                  }
              }

              if (lines_cleared.length > 0)
                  this.animateLineClear(lines_cleared, 8*lines_cleared.length);

              return lines_cleared.length;
          }

          placeBlock(block, pos){
              var pos_x = pos[0];
              var pos_y = pos[1];
              var rot   = pos[2];
              var block_number = this.state.block_history.length-1;

              block = this.rotateArray(block, rot);

              for (var y=0; y<block.length; y++) {
                  for (var x=0; x<block[y].length; x++) {
                      if (block[y][x] == 1) {
                          this.state.game_array[pos_y + y][pos_x + x] = block_number;
                      }
                  }
              }
          }

          canMove(block, pos, dir){
              var pos_x = pos[0];
              var pos_y = pos[1];
              var rot   = pos[2];

              // Move position
              if (dir == this.direction.down)  pos_y++;
              if (dir == this.direction.left)  pos_x--;
              if (dir == this.direction.right) pos_x++;
              if (dir == this.direction.ccw)   rot++;
              if (dir == this.direction.cw)    rot--;

              // Rotate
              var block_array = this.rotateArray(block, rot);

              for (var y=0; y<block_array.length; y++) {
                  for (var x=0; x<block_array[y].length; x++) {
                      if (block_array[y][x] != 0){
                          // Check for out of bounds
                          if (pos_x + x < 0 || pos_x + x >= this.dimension.game_width)
                              return false;
                          if (pos_y + y >= this.dimension.game_height + this.dimension.top_buffer)
                              return false;
                          // Compare against game array
                          if (this.state.game_array[pos_y + y][pos_x + x] != this.EMPTY)
                              return false;
                      }
                  }
              }

              // Can move!
              return true;
          }

          isAnimating(){
              for (var i=0; i<this.state.animation_timer.length; i++)
                  if (this.state.animation_timer[i] != null) return true;
              return false;
          }

          clearAnimationTimer(n=-1){
              // Clear all timers
              if (n == -1) {
                  for (var i=0; i<this.state.animation_timer.length; i++){
                      clearTimeout(this.state.animation_timer[i]);
                      this.state.animation_timer[i] = null;
                  }
              } else {
                  clearTimeout(this.state.animation_timer[n]);
                  this.state.animation_timer[n] = null;
              }
          }

          animateDrop(block){
              this.clearAnimationTimer(3);

              if (this.canMove(block, this.state.block_position, this.direction.down) == true){
                  this.move(this.direction.down);
                  this.state.block_position[3] += 1; // Bonus point per square for dropping fast
                  this.state.animation_timer[3] = setTimeout(() => this.animateDrop(block), 5);
              }
          }

          resetMainLoopTimeout(){
              clearTimeout(this.state.timer);
              this.state.timer = setTimeout(() => this.main_loop(), this.speed);
              return;
          }

          move(dir, usermove=false){
              // Get shape template
              var thisBlock = this.state.block_history[this.state.block_history.length-1];

              // Is valid move?
              if (this.canMove(thisBlock, this.state.block_position, dir) == false)
                  return;

              // Actually move block
              if (dir == this.direction.down){
                  this.state.block_position[1] = this.state.block_position[1] + 1;
                  this.state.block_position[3] += 1 // Get point per step for slow dropping
                  /* There's a bug here. The timer should reset when a user pressed the down arrow.
                     But this code isn't doing the trick. Debug this when you have time...
                  if (usermove == true) {
                      this.redraw();
                      resetMainLoopTimeout;
                  }
                  */
              }

              if (dir == this.direction.drop){
                  this.state.block_position[3] = 0; // only get points from where it was fast dropped
                  this.animateDrop(thisBlock);
                  // Call mainloop now so it registers the block
                  clearTimeout(this.state.timer)
                  this.main_loop();
              }

              if (dir == this.direction.left){
                  this.state.block_position[3] = 0; // only get points for how far it dropped without shifting
                  this.state.block_position[0] = this.state.block_position[0] - 1;
              }

              if (dir == this.direction.right){
                  this.state.block_position[3] = 0; // only get points for how far it dropped without shifting
                  this.state.block_position[0] = this.state.block_position[0] + 1;
              }

              if (dir == this.direction.ccw){
                  this.state.block_position[3] = 0; // only get points for how far it dropped without shifting
                  this.state.block_position[2] = this.state.block_position[2] + 1;
              }

              if (dir == this.direction.cw){
                  this.state.block_position[3] = 0; // only get points for how far it dropped without shifting
                  this.state.block_position[2] = this.state.block_position[2] + 3;
              }

              // Redraw
              this.redrawGameField();
              this.redrawCurrentBlock();
          }

          toggleDebugMode(){
              if (this.settings.debug == true)
                  this.settings.debug = false;
              else
                  this.settings.debug = true;
          }

          toggleCheatMode(){
              if (this.settings.cheat == true) {
                  this.settings.cheat = false;
                  this.rules.base_speed = 890;
                  this.colors.black = "#000000";
              } else {
                  this.settings.cheat = true;
                  this.rules.base_speed = 8900;
                  this.colors.black = "#AA0000";
                  this.state.imacheater = true;
              }
              if (this.state.game_active == true){
                  this.redrawGameField();
                  this.redrawCurrentBlock();
              }
          }

          toggleGhostMode(){
              if (this.settings.showGhostBlock == true)
                  this.settings.showGhostBlock = false;
              else
                  this.settings.showGhostBlock = true;
              this.redraw();
          }

          toggleExtraPieces(){
              if (this.settings.useExtraPieces == true)
                  this.settings.useExtraPieces = false;
              else
                  this.settings.useExtraPieces = true;
              this.redraw();
          }

          user_move(e){
              // Switch for general commands
              switch (e.keyCode){
              case this.key.n:
                  if (this.state.game_active == false)
                      this.start();
                  break;

              case this.key.g:
                  this.toggleGhostMode();
                  break;

              case this.key.d:
                  this.toggleDebugMode();
                  break

              case this.key.c:
                  this.toggleCheatMode();
                  break

              case this.key.e:
                  if (this.state.game_active == false)
                      this.toggleExtraPieces();
                  break;

              case this.key.p:
                  if (this.state.game_active == true)
                      this.togglePause();
                  break;

              case this.key.q:
                  this.endGame();
                  break;
              }

              // Switch for movement commands
              if (this.state.game_active == true && this.isAnimating() == false && this.state.game_paused == false) {
                  var direction = null;
                  switch(e.keyCode){
                  case this.key.space:
                      direction = this.direction.drop;
                      break;

                  case this.key.left_arrow:
                  case this.key.j:
                      direction = this.direction.left;
                      break;

                  case this.key.up_arrow:
                  case this.key.i:
                      direction = this.direction.ccw;
                      break;

                  case this.key.o:
                      direction = this.direction.cw;
                      break;

                  case this.key.right_arrow:
                  case this.key.l:
                      direction = this.direction.right;
                      break;

                  case this.key.down_arrow:
                  case this.key.k:
                      direction = this.direction.down;
                      break;

                  case this.key.plus:
                      this.state.level += 1;
                      this.redrawFrame();
                      this.drawGameInformation();
                      break;

                  case this.key.minus:
                      if (this.settings.cheat == true) {
                          this.state.level -= 1;
                          this.drawGameInformation();
                      }
                      break;

                  case this.key.s:
                      if (this.settings.cheat == true) {
                          // Replace current block definition with an empty block
                          this.state.block_history[this.state.block_history.length-1] = {
                              shape : [[-1]],
                              rotations : 1,
                              color : { r:0x00, g:0x00, b:0x00 },
                          };
                          // Drop it like it's hot
                          direction = this.direction.drop;
                      }
                      break;

                  default:
                      return;
                  }
                  this.move(direction, true);
              }
          }

          check_high_score() {
              // Retrieve Scores
              var high_scores = localStorage.getItem("ntris");

              // Retrieve scores from previous location if null
              if (high_scores == null) {
                  high_scores = localStorage.getItem("scores");
                  localStorage.setItem("ntris", high_scores);
              }

              // Convert from JSON
              if (high_scores)
                  high_scores = JSON.parse(high_scores);
              else
                  high_scores = [];

              // Go through each and see if it's in the top ten
              var i     = 0;
              var place = 0;
              for (i=0; i<high_scores.length; i++){
                  // Check to see if extras is there. If not, assume old scores were extras = false
                  if (! high_scores[i].hasOwnProperty('extra')){
                      high_scores[i]['extra'] = false;
                  }

                  if (this.settings.useExtraPieces == high_scores[i].extra) {
                      place += 1;

                      if (this.state.score > high_scores[i].score) {
                          break;
                      }
                  }
              }

              // Record new score
              if (place <= 10) {
                  const nth = ["first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh"]
                  var user_name = null;
                  
                  if (this.state.imacheater == true){
                      alert("You would have gotten a high score, but you're a cheater!");
                      return;
                  } else {
                      user_name = prompt("New high score! You got "+nth[i]+" place. Enter name", "Anonymous");
                  }

                  if (user_name != null){
                      high_scores.splice(i, 0, {
                          name  : user_name,
                          level : this.state.level,
                          score : this.state.score,
                          extra : this.settings.useExtraPieces,
                          lines : this.state.lines,
                          date  : new Date().toString()
                      });

                      localStorage.ntris = JSON.stringify(high_scores);
                  }

                  // Update overlay with new high score!
                  this.redraw();
              }
          }

          game_over_overlay(printed_score=3){
              var wait = 15; // miliseconds
              if (printed_score < this.state.score) {
                  printed_score *= 2;
                  printed_score += Math.floor(Math.random() * 5);
                  if (printed_score > this.state.score) {
                      printed_score = this.state.score;
                      wait = 1000;
                  }
                  this.state.game_overlay = [
                      {color  : "white",
                       size   : 40,
                       font   : "SegmentedAlpha",
                       align  : "center",
                       y      : 170,
                       x      : null,
                       string : "GAME OVER"},
                      {color  : "white",
                       size   : 20,
                       font   : "Arial",
                       align  : "left",
                       y      : 200,
                       x      : (this.dimension.left_buffer + 2) * this.dimension.starting_square_size,
                       string : "SCORE: "},
                      {color  : "white",
                       size   : 20,
                       font   : "Segmented",
                       align  : "right",
                       y      : 200,
                       x      : (this.dimension.left_buffer + this.dimension.game_width) * this.dimension.starting_square_size,
                       string : printed_score}
                  ],

                  this.redraw();
                  this.state.timer = setTimeout(() => this.game_over_overlay(printed_score), wait);
              } else {
                  this.check_high_score();
              }
          }

          endGame(){
              if (this.state.game_active == false) return;
              clearTimeout(this.state.timer);
              this.clearAnimationTimer();
              this.state.game_active = false;
              this.game_over_overlay();
          }

          main_loop(){
              // See if we are paused
              if (this.state.game_paused == true) return;

              if (this.settings.debug == true){
                  this.ctx.fillStyle = this.colors.background;
                  this.ctx.fillRect(this.canvas.width-(this.dimension.right_buffer*this.dimension.square_size), this.canvas.height-20, this.dimension.right_buffer*this.dimension.square_size, this.canvas.height);
              }
              // See if animations are going, and wait for them to finish
              if (this.isAnimating() == true){
                  if (this.settings.debug == true){
                      this.ctx.font = "12px SegmentedAlpha";
                      this.ctx.fillStyle = this.colors.red;
                      this.ctx.fillText("animating", this.canvas.width - 10, this.canvas.height-10);
                  }
                  clearTimeout(this.state.timer);
                  this.state.timer = setTimeout(() => this.main_loop(), 10);
                  return;
              }

              // Get shape template
              var block = this.state.block_history[this.state.block_history.length-1];

              // Set timeout for next cycle
              this.speed = this.rules.base_speed * Math.pow(this.rules.speedup_multiplier, this.state.level -1);
              this.speed = this.speed < this.rules.max_speed ? this.rules.max_speed : this.speed;

              // See if a block has been placed
              if (this.canMove(block, this.state.block_position, this.direction.down) == false){
                  // Set speed to 0 so we don't wait for an entire cycle to show new block
                  this.speed = 0;

                  // Add block array to array
                  this.placeBlock(block, this.state.block_position);

                  // Look for lines to clear, Update Scores and Counts
                  var lines_cleared = this.lookForLines();
                  this.state.score += this.rules.line_scores[lines_cleared] * this.state.level;
                  if (Math.floor(this.state.lines / 10) < Math.floor((this.state.lines + lines_cleared) / 10)){
                      this.state.level += 1;
                      this.redrawFrame();
                  }
                  this.state.lines += lines_cleared;

                  // 1 point per block for distance fallen, double for fast drop
                  this.state.score += this.state.block_position[3] > 40 ? 40 : this.state.block_position[3];
                  this.drawGameInformation();

                  // Animate blocks scrolling up
                  this.animateUpcomingBlocks(0);

                  // See if game is over
                  if (this.isGameOver() == true && lines_cleared == 0){
                      this.endGame();
                      return;
                  }
              }

              // Move current block down
              this.move(this.direction.down);

              // See if window/game lost focus, and pause
              if(!document.hasFocus()) this.pause();

              // Set timer
              this.state.timer = setTimeout(() => this.main_loop(), this.speed);
          }

          shuffle(array) {
              let counter = array.length;

              // While there are elements in the array
              while (counter > 0) {
                  // Pick a random index
                  let index = Math.floor(Math.random() * counter);

                  // Decrease counter by 1
                  counter--;

                  // And swap the last element with it
                  let temp = array[counter];
                  array[counter] = array[index];
                  array[index] = temp;
              }

              return array;
          }

          add_block(){
              // Make sure first block of game is from more restrictive set
              if (this.state.block_upcoming.length == 0){
                  var t = this.rules.startingBlocks[Math.floor(Math.random() * this.rules.startingBlocks.length)];
                  this.state.block_upcoming.push(this.block_defs[t]);
              }

              // If there are fewer than 8 pieces, add a whole set of pieces in random order
              while (this.state.block_upcoming.length < 8){
                  for (var t of this.shuffle(this.state.blockset))
                      this.state.block_upcoming.push(this.block_defs[t]);
              }

              // Move next block from block_upcoming array to block_history array
              this.state.block_history.push(this.state.block_upcoming[0]);
              this.state.block_upcoming = this.state.block_upcoming.slice(1);

              // Set position of previous 'next' block to top, center
              var this_block = this.state.block_history[this.state.block_history.length-1];
              this.state.block_position = [(this.dimension.game_width/2) - 1,
                                           this.dimension.top_buffer - this_block.shape.length - 1,
                                           0,
                                           0];
          }

          resizeCanvas(width, height){
              this.canvas.height = width * this.dimension.square_size;
              this.canvas.width  = height * this.dimension.square_size;
              document.getElementById("content").setAttribute("style", "width: " + this.canvas.width + "px;");
          }

          clearScreen(){
              // Setup Game field
              var total_height = this.dimension.game_height + this.dimension.top_buffer + this.dimension.game_border;
              var total_width  = this.dimension.game_width + this.dimension.left_buffer + this.dimension.right_buffer + (2*this.dimension.game_border);
              this.resizeCanvas(total_width, total_height);

              // Setup Array
              this.state.game_array = [];
              for (var y=0; y<this.dimension.game_height+this.dimension.top_buffer; y++){
                  var temp = [];
                  for (var x=0; x<this.dimension.game_width; x++){
                      temp.push(this.EMPTY);
                  }
                  this.state.game_array.push(temp);
              }

              this.redraw();
              return;
          }

          pause(){
              if (this.state.game_active == true && this.state.game_paused == false){
                  this.state.game_paused = true;
                  this.state.game_overlay = this.overlays.paused;
                  this.redraw();
                  clearTimeout(this.state.timer);
              }
          }

          unpause(){
              if (this.state.game_active == true && this.state.game_paused == true){
                  this.state.game_paused = false;
                  this.state.game_overlay = null;
                  this.redraw();
                  this.main_loop();
              }
          }

          togglePause(){
              if (this.state.game_active == true){
                  if (this.state.game_paused == false){
                      this.pause();
                  } else {
                      this.unpause();
                  }
              }
          }

          start(){
              this.state.game_overlay = null; // Clear text overlays
              this.togglePause();  // Toggle pause

              // Start game
              if (this.state.game_active == false) {
                  this.clearScreen();      // Clear the screen
                  this.state.lines = 0;
                  this.state.level = 1;
                  this.state.score = 0;
                  this.state.block_history = [];
                  this.state.block_upcoming = []; // Clear next blocks

                  // Reset cheating...
                  this.state.imacheater = false;
                  if (this.settings.cheat == true)
                      this.toggleCheatMode();

                  // Set which type of blocks for game
                  this.state.blockset = this.rules.tetrominoes;
                  if (this.settings.useExtraPieces == true)
                      this.state.blockset = Object.keys(this.block_defs);
                  this.add_block();         // Populate upcoming blocks
                  this.state.game_active = true;
                  this.state.game_paused = false;
                  this.redraw();            // Draw the screen
                  this.main_loop();
              }
          }

          drawUpcomingBlocks(offset=0){
              // Clear left section
              this.ctx.fillStyle = this.colors.background;
              this.ctx.fillRect(0, 0, this.dimension.left_buffer * this.dimension.square_size, this.canvas.height);

              for (var i=0; i<7; i++){
                  var next_block        = this.state.block_upcoming[i];
                  var next_block_height = next_block.shape.length;
                  var next_block_width  = next_block.shape[0].length;
                  var next_block_left   = Math.floor((this.dimension.left_buffer / 2) - (next_block_width / 2));
                  this.drawBlock(this.ctx,
                                 next_block,
                                 next_block_left,
                                 this.dimension.top_buffer - next_block_height + (4 * i) + offset,
                                 0);
              }
          }

          animateUpcomingBlocks(n){
              this.clearAnimationTimer(2);

              if (n > -5){
                  this.drawUpcomingBlocks(n);
                  n--;
                  this.state.animation_timer[2] = setTimeout(() => this.animateUpcomingBlocks(n), 20);
              } else {
                  // Finally, add a block
                  this.add_block();
                  // and redraw to remove the added block from left side
                  this.drawUpcomingBlocks(0);
              }
          }

          redrawGameField(){
              this.ctx.fillStyle = this.colors.black;
              this.ctx.fillRect(
                  this.dimension.square_size * (this.dimension.left_buffer + this.dimension.game_border),
                  0,
                  this.dimension.square_size * (this.dimension.game_width),
                  this.dimension.square_size * (this.dimension.top_buffer + this.dimension.game_height)
              );

              for (var y=0; y<this.state.game_array.length; y++){
                  for (var x=0; x<this.state.game_array[y].length; x++){
                      if (this.state.game_array[y][x] == this.EMPTY) continue;
                      this.drawChisledBrick(this.ctx, x + this.dimension.left_buffer + this.dimension.game_border, y, this.dimension.square_size,
                                            this.state.block_history[this.state.game_array[y][x]].color,
                                            y > 0                 ? this.state.game_array[y][x] == this.state.game_array[y-1][x] : false,
                                            x < this.state.game_array[0].length-1 ? this.state.game_array[y][x] == this.state.game_array[y][x+1] : false,
                                            y < this.state.game_array.length-1    ? this.state.game_array[y][x] == this.state.game_array[y+1][x] : false,
                                            x > 0                 ? this.state.game_array[y][x] == this.state.game_array[y][x-1] : false,
                                           );
                  }
              }
          }

          redrawCurrentBlock(){
              var this_block = this.state.block_history[this.state.block_history.length-1];

              // Ghost block
              if (this.settings.showGhostBlock == true){
                  // Get lowest it can go
                  var ghost_pos = this.state.block_position.slice();

                  while (this.canMove(this_block, ghost_pos, this.direction.down) == true)
                      ghost_pos[1]++;
                  this.drawBlockInGameField(this.ctx, this_block, this.state.block_position[0], ghost_pos[1], this.state.block_position[2], true);
              }

              // Draw current block last so it's always on top
              this.drawBlockInGameField(this.ctx, this_block, this.state.block_position[0], this.state.block_position[1], this.state.block_position[2]);
          }

          redrawBackground(){
              // Draw black background
              this.ctx.fillStyle = this.colors.background;
              this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
              this.ctx.fillStyle = this.colors.black;
              this.ctx.fillRect((this.dimension.left_buffer + this.dimension.game_border)*this.dimension.square_size, 0, this.dimension.game_width*this.dimension.square_size, this.canvas.height);
          }

          redrawFrame() {
              // Draw border around game field
              for (var y=0; y<=this.dimension.game_height + this.dimension.game_border; y++)
                  for (var x=0; x<this.dimension.game_width + (2 * this.dimension.game_border); x++)
                      if (y == this.dimension.game_height || (x == 0 || x == this.dimension.game_width + 1))
                          this.drawChisledBrick(this.ctx, x + this.dimension.left_buffer, y + this.dimension.top_buffer, this.dimension.square_size,
                                                this.hexToRGB(this.level_colors[this.state.level % this.level_colors.length]), //{r:0x88, g:0x88, b:0x88}, // Color here?
                                                y == 0 || y == this.dimension.game_height && x != 0 && x != this.dimension.game_width + 1 ? false : true,
                                                y <  this.dimension.game_height || y == this.dimension.game_height && x == this.dimension.game_width + 1 ? false : true,
                                                y == this.dimension.game_height ? false : true,
                                                y <  this.dimension.game_height || y == this.dimension.game_height && x == 0 ? false : true,
                                               );
          }

          redraw(){
              // Redraw background
              this.redrawBackground();
              this.redrawFrame();

              // Draw each block in game field
              this.redrawGameField();

              // Draw upcoming blocks
              if (this.state.block_upcoming.length > 0)
                  this.drawUpcomingBlocks();

              // Draw current block
              if (this.state.game_active == true) {
                  this.redrawCurrentBlock();
              }

              // Draw right hand side
              this.drawGameInformation();

              // Draw game overlay
              if (this.state.game_overlay != null){
                  this.text_overlay(this.state.game_overlay);
              }
          }

          drawGameInformation(){
              // Clear section and Draw black background
              this.ctx.fillStyle = this.colors.background;
              this.ctx.fillRect(this.canvas.width-(this.dimension.right_buffer*this.dimension.square_size), 0, this.dimension.right_buffer*this.dimension.square_size, this.canvas.height);

              // Right align everything
              var ralign = this.canvas.width - (this.dimension.square_size * 1);
              this.ctx.textAlign = "right";

              // Draw Game Name
              this.ctx.fillStyle = this.colors.light_grey;
              var title_size = Math.floor(this.canvas.width / 13);
              this.ctx.font = "Bold " + title_size + "px Arial";
              this.ctx.fillText("N-tris", ralign, 0 + (title_size * 1.3));

              // Set up spacing based on this.canvas size
              var label_size = Math.floor(this.canvas.width / 28);
              var digit_size = Math.floor(this.canvas.width / 18);
              var alpha_size = Math.floor(this.canvas.width / 21);
              var line_spacing = Math.floor(this.canvas.width / 18);

              // Draw game information
              var y = this.dimension.top_buffer * this.dimension.square_size + label_size;
              this.ctx.fillStyle = this.colors.light_grey;
              this.ctx.font = label_size + "px Arial";
              this.ctx.fillText("Score",         ralign, y + (0 * line_spacing));
              this.ctx.fillText("Lines",         ralign, y + (2 * line_spacing));
              this.ctx.fillText("Level",         ralign, y + (4 * line_spacing));
              this.ctx.fillText("Extra Pieces", ralign, y + (6 * line_spacing));
              this.ctx.fillText("Ghost Block",   ralign, y + (8 * line_spacing));
              this.ctx.fillStyle = this.colors.green;
              this.ctx.font = digit_size + "px Segmented";
              this.ctx.fillText(this.state.score,                ralign, y + (1 * line_spacing));
              this.ctx.fillText(this.state.lines,                ralign, y + (3 * line_spacing));
              this.ctx.fillText(this.state.level, ralign, y + (5 * line_spacing));
              this.ctx.font = alpha_size + "px SegmentedAlpha";
              this.ctx.fillStyle = this.state.game_active == true ? this.colors.amber : this.colors.green;
              this.ctx.fillText(this.settings.useExtraPieces == true ? "Enabled" : "Disabled", ralign, y + (7 * line_spacing));
              this.ctx.fillStyle = this.colors.green;
              this.ctx.fillText(this.settings.showGhostBlock == true ? "Enabled" : "Disabled", ralign, y + (9 * line_spacing));

              // Draw help information
              y = this.canvas.height - this.dimension.square_size;
              var note_spacing = this.canvas.width / 45;
              this.ctx.fillStyle = this.colors.light_grey;
              this.ctx.font = "Italic " + this.canvas.width / 50 + "px Arial";
              var notes = [
                  "(n) New Game",
                  "(arrows) Move",
                  "(up arrow) Rotate",
                  "(space) Drop",
                  "(p) Pause",
                  "(q) Quit Game",
                  "(e) Extra Pieces",
                  "(g) Ghost Mode"
              ];
              for (var i=0; i<notes.length; i++)
                  this.ctx.fillText(notes[i], ralign, y - ((notes.length - i) * note_spacing));
          }

          rotateArray(a, n){
              var rotated = a.shape.slice(); // Copies the array
              const height = rotated[0].length;;
              const width = rotated.length;
              const rotation = n % a.rotations;

              for (var rotate=0; rotate<rotation; rotate++){
                  // Create new array of the same size
                  var tmp = [];
                  for (var y=0; y<height; y++){
                      var t_row = [];
                      for (var x=0; x<width; x++){
                          t_row.push(0);
                      }
                      tmp.push(t_row);
                  }

                  // Copy data to new, empty array
                  for (var y=0; y<height; y++){
                      for (var x=0; x<width; x++){
                          tmp[y][x] = rotated[x][height-y-1];
                      }
                  }

                  // Overwrite rotated array
                  rotated = tmp.slice();
              }

              return rotated;
          }

          drawBlockInGameField(ctx, def, bx, by, r, outline=false){
              // offset so it draws on the game board
              this.drawBlock(ctx, def, this.dimension.left_buffer + this.dimension.game_border + bx, by, r, outline);
          }

          drawBlock(ctx, def, bx, by, r, outline=false){
              // rotate block array
              var block = this.rotateArray(def, r);;
              var width = def.shape[0].length;
              var height = def.shape.length;
              var color = def.color;

              for (var y=0; y<height; y++){
                  for (var x=0; x<width; x++){
                      if (block[y][x] > 0){
                          this.drawChisledBrick(ctx,
                                                (bx + x),
                                                (by + y),
                                                this.dimension.square_size,
                                                color,
                                                y > 0                 ? block[y][x] == block[y-1][x] : false,
                                                x < block[0].length-1 ? block[y][x] == block[y][x+1] : false,
                                                y < block.length-1    ? block[y][x] == block[y+1][x] : false,
                                                x > 0                 ? block[y][x] == block[y][x-1] : false,
                                                outline,
                                               )
                      } else if (block[y][x] == -2) {
                          // Draw background where empty blocks are
                          this.ctx.fillStyle = this.colors.black;
                          this.ctx.fillRect((bx + x) * this.dimension.square_size,
                                            (by + y) * this.dimension.square_size,
                                            this.dimension.square_size,
                                            this.dimension.square_size
                                           );
                      }
                  }
              }

          }

          hexToRGB(s) {
              return {
                  r: parseInt(s.slice(1,3), 16),
                  g: parseInt(s.slice(3,5), 16),
                  b: parseInt(s.slice(5,7), 16),
              };
          }

          shiftColor(c, d){
              var r = c.r - d;
              var g = c.g - d;
              var b = c.b - d;

              r = r < 0 ? 0 : r;
              g = g < 0 ? 0 : g;
              b = b < 0 ? 0 : b;
              r = r > 0xff ? 0xff : r;
              g = g > 0xff ? 0xff : g;
              b = b > 0xff ? 0xff : b;

              return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
          }

          drawChisledBrick(ctx, x, y, l, c, n, e, s, w, outline=false){
              // Define Chisledness
              var edge = Math.floor(this.dimension.square_size * this.dimension.block_chisled_ratio);
              if (outline == true)
                  edge = Math.floor(this.dimension.square_size * this.dimension.block_outline_ratio);
              if (edge < this.dimension.block_min_edge_size)
                  edge = this.dimension.block_min_edge_size;

              // Adjust x, y coordinates
              x *= l;
              y *= l;

              // Define colors
              var c_lightest = this.shiftColor(c, -0x64);;
              var c_light    = this.shiftColor(c, -0x32);
              var c_normal   = this.shiftColor(c, 0x0);
              var c_dark     = this.shiftColor(c, 0x32);
              var c_darkest  = this.shiftColor(c, 0x64);
              if (outline == true){
                  var c_lightest = this.shiftColor(c, 0x0);
                  var c_light    = this.shiftColor(c, 0x0);
                  var c_normal   = "rgba(0,0,0,0)";
                  var c_dark     = this.shiftColor(c, 0x0);
                  var c_darkest  = this.shiftColor(c, 0x0);
              }

              // Fill in background color
              ctx.fillStyle = c_normal;
              ctx.fillRect(x, y, l, l);

              // North Edge
              if (n == false){
                  ctx.beginPath();
                  ctx.moveTo(x, y);
                  if (w == true)
                      ctx.lineTo(x, y+edge);
                  else
                      ctx.lineTo(x+edge, y+edge);
                  if (e == true)
                      ctx.lineTo(x+l, y+edge);
                  else
                      ctx.lineTo(x+l-edge, y+edge);
                  ctx.lineTo(x+l, y);
                  ctx.fillStyle = c_lightest;
                  ctx.fill();
              }

              // West Edge
              if (w == false){
                  ctx.beginPath();
                  ctx.moveTo(x, y);
                  if (n == true)
                      ctx.lineTo(x+edge, y);
                  else
                      ctx.lineTo(x+edge, y+edge);
                  if (s == true)
                      ctx.lineTo(x+edge, y+l);
                  else
                      ctx.lineTo(x+edge, y+l-edge);
                  ctx.lineTo(x, y+l);
                  ctx.fillStyle = c_light;
                  ctx.fill();
              }

              // East Edge
              if (e == false){
                  ctx.beginPath();
                  ctx.moveTo(x+l, y);
                  if (n == true)
                      ctx.lineTo(x+l-edge, y);
                  else
                      ctx.lineTo(x+l-edge, y+edge);
                  if (s == true)
                      ctx.lineTo(x+l-edge, y+l);
                  else
                      ctx.lineTo(x+l-edge, y+l-edge);
                  ctx.lineTo(x+l, y+l);
                  ctx.fillStyle = c_dark;
                  ctx.fill();
              }

              // South Edge
              if (s == false){
                  ctx.beginPath();
                  ctx.moveTo(x, y+l);
                  if (w == true)
                      ctx.lineTo(x, y+l-edge);
                  else
                      ctx.lineTo(x+edge, y+l-edge);
                  if (e == true)
                      ctx.lineTo(x+l, y+l-edge);
                  else
                      ctx.lineTo(x+l-edge, y+l-edge);
                  ctx.lineTo(x+l, y+l);
                  ctx.fillStyle = c_darkest;
                  ctx.fill();
              }

              // NW Corner
              if (n == true && w == true){
                  ctx.beginPath();
                  ctx.moveTo(x, y);
                  ctx.lineTo(x+edge, y);
                  ctx.lineTo(x+edge, y+edge);
                  ctx.fillStyle = c_light;
                  ctx.fill();
                  ctx.beginPath();
                  ctx.moveTo(x, y);
                  ctx.lineTo(x, y+edge);
                  ctx.lineTo(x+edge, y+edge);
                  ctx.fillStyle = c_lightest;
                  ctx.fill();
              }

              // NE Corner
              if (n == true && e == true){
                  ctx.beginPath();
                  ctx.moveTo(x+l, y);
                  ctx.lineTo(x+l-edge, y);
                  ctx.lineTo(x+l-edge, y+edge);
                  ctx.fillStyle = c_dark;
                  ctx.fill();
                  ctx.beginPath();
                  ctx.moveTo(x+l, y);
                  ctx.lineTo(x+l, y+edge);
                  ctx.lineTo(x+l-edge, y+edge);
                  ctx.fillStyle = c_lightest;
                  ctx.fill();
              }

              // SW Corner
              if (s == true && w == true){
                  ctx.beginPath();
                  ctx.moveTo(x, y+l);
                  ctx.lineTo(x+edge, y+l);
                  ctx.lineTo(x+edge, y+l-edge);
                  ctx.fillStyle = c_light;
                  ctx.fill();
                  ctx.beginPath();
                  ctx.moveTo(x, y+l);
                  ctx.lineTo(x, y+l-edge);
                  ctx.lineTo(x+edge, y+l-edge);
                  ctx.fillStyle = c_darkest;
                  ctx.fill();
              }

              // SE Corner
              if (s == true && e == true){
                  ctx.beginPath();
                  ctx.moveTo(x+l, y+l);
                  ctx.lineTo(x+l-edge, y+l);
                  ctx.lineTo(x+l-edge, y+l-edge);
                  ctx.fillStyle = c_dark;
                  ctx.fill();
                  ctx.beginPath();
                  ctx.moveTo(x+l, y+l);
                  ctx.lineTo(x+l, y+l-edge);
                  ctx.lineTo(x+l-edge, y+l-edge);
                  ctx.fillStyle = c_darkest;
                  ctx.fill();
              }
          }

          font_sizer(pixels, font){
              return (pixels * this.dimension.em) + "px " + font;
          }

          text_overlay(string_array){
              // Black out playing field
              this.ctx.fillStyle = "rgba(0,0,0,.7)";
              this.ctx.fillRect((this.dimension.left_buffer + this.dimension.game_border) * this.dimension.square_size,
                                0,
                                this.dimension.game_width * this.dimension.square_size,
                                (this.dimension.top_buffer + this.dimension.game_height) * this.dimension.square_size);

              // Print desired message in upper section
              for (var string of string_array){
                  this.ctx.fillStyle = this.colors[string.color];
                  this.ctx.font      = this.font_sizer(string.size, string.font);
                  this.ctx.textAlign = string.align;
                  var y              = string.y * this.dimension.em;
                  if (string.y == null) y = this.canvas.height/2;
                  var x              = string.x * this.dimension.em;
                  if (string.x == null) x = this.canvas.width/2;
                  this.ctx.fillText(string.string, x, y);
              }

              // Print high scores in remaining portion
              var high_scores = localStorage.getItem("ntris");
              var high_score_size = 14;
              var high_score_spacing = this.dimension.em * 22;

              // Convert from JSON
              if (high_scores){
                  high_scores = JSON.parse(high_scores);
                  var y = this.canvas.height/2;

                  // Header
                  this.ctx.font = this.font_sizer(18, "SegmentedAlpha");
                  this.ctx.textAlign = "center";
                  this.ctx.fillText("High Scores", this.canvas.width/2, y);
                  y += high_score_spacing;

                  var scores_printed = 0;
                  for(var i=0; i<high_scores.length; i++){
                      var score = high_scores[i];

                      if (score.extra != this.settings.useExtraPieces)
                          continue;

                      if (scores_printed == 10)
                          break;

                      scores_printed += 1;

                      // Name
                      this.ctx.font = this.font_sizer(high_score_size, "SegmentedAlpha");
                      this.ctx.textAlign = "left";
                      this.ctx.fillText(score.name, (this.dimension.left_buffer + 2) * this.dimension.square_size, y);

                      // Score
                      this.ctx.font = this.font_sizer(high_score_size, "Segmented");
                      this.ctx.textAlign = "right";
                      this.ctx.fillText(score.score, (this.dimension.left_buffer + this.dimension.game_width - 1) * this.dimension.square_size, y);

                      // Level
                      this.ctx.font = this.font_sizer(high_score_size, "Segmented");
                      this.ctx.textAlign = "right";
                      this.ctx.fillText(score.level, (this.dimension.left_buffer + this.dimension.game_width) * this.dimension.square_size, y);

                      y += high_score_spacing;
                  }
              }
          }

          resizeGame(){
              var windowWidth = window.innerWidth
                  || document.documentElement.clientWidth
                  || document.body.clientWidth;
              var windowHeight = window.innerHeight
                  || document.documentElement.clientHeight
                  || document.body.clientHeight;
              var maxWindowSize = Math.min(windowHeight, windowWidth);

              var gameWidth = this.dimension.left_buffer + this.dimension.right_buffer + this.dimension.game_width + (this.dimension.game_border * 2);
              var gameHeight = this.dimension.top_buffer + this.dimension.game_height + this.dimension.game_border;
              var minGameArea = Math.max(gameWidth, gameHeight);

              // Set new square size
              this.dimension.square_size = Math.floor(maxWindowSize / (minGameArea * 1.1));
              if (this.dimension.square_size < this.dimension.square_min_size)
                  this.dimension.square_size = this.dimension.square_min_size;

              // Set new font scaling
              this.dimension.em = this.dimension.square_size / this.dimension.starting_square_size;

              // Redraw everything
              this.resizeCanvas(gameWidth, gameHeight);
              this.redraw();
          }

          firstRun(){
              this.state.game_overlay = this.overlays.firstrun;
              this.resizeGame();
          }

      }

var tetris_instance = new tetris(document.getElementById("canvas"));

// Keyboard listeners
//document.addEventListener('keyup', function(e) {});
document.addEventListener('keydown', function(e) {
    tetris_instance.user_move(e);
});




    </script>
  </body>
</html>
