<!DOCTYPE html>

<html>
  <head>
    <title>N-tris</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=600px, user-scalable=no" /> <!-- disabled in iOS 10+ -->    <style>
      body {
          background:#aaa;
          color:#000;
	  font-family:sans-serif;
      }

      div#content {
          #background:#fff;
      }

      h1 {
	  margin:10px;
	  font-size:3em;
      }

      /*Font Faces*/
      @font-face {
	  font-family: "Segmented";
	  src: url('fonts/Segment7Standard.otf');
      }

      @font-face {
	  font-family: "SegmentedAlpha";
	  src: url('fonts/Digital7Regular.otf');
      }
</style>
  </head>

    <body onload="setFocus()">

    <div id="content" style="width:512px; margin: 0 auto 0 auto; padding:15px;">
      <h1>N-tris</h1>
      <canvas id="canvas" width="512" height="512" onclick="start();" style="border:1px solid black; touch-action: manipulation"></canvas><br>
      <br>
      <input id="myInput" type="text" onblur="" onkeydown="user_move(event)" style="width: 0px; position:relative; left:-10000px;"></input>
    </div>

    <script>
// Comment

var block_defs = {
    // Tetrominoes
    I : {
	shape : [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]],
	rotations : 2,
	color : { r:0xFF, g:0x00, b:0x00 }, // Red
    },
    Z : {
	shape : [[1,1,0], [0,1,1], [0,0,0]],
	rotations : 2,
	color : { r:0xFF, g:0x92, b:0x00 }, // Orange
    },
    J : {
	shape : [[0,0,0], [1,1,1], [0,0,1]],
	rotations : 4,
	color : { r:0xDB, g:0xB6, b:0x00 }, // Yellow
    },
    T : {
	shape : [[0,0,0], [1,1,1], [0,1,0]],
	rotations : 4,
	color : { r:0x49, g:0xB6, b:0x00 }, // Green
    },
    S : {
	shape : [[0,1,1], [1,1,0], [0,0,0]],
	rotations : 2,
	color : { r:0x00, g:0xB6, b:0xAA }, // Cyan
    },
    O: {
	shape : [[0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0]],
	rotations : 1,
	color : { r:0x00, g:0x49, b:0xFF }, // Blue
    },
    L : {
	shape : [[0,0,0], [1,1,1], [1,0,0]],
	rotations : 4,
	color : { r:0xDB, g:0x00, b:0xFF }, // Purple
    },

    // Pentominoes
    LongJ : {
	shape : [[0,0,0,0], [1,0,0,0], [1,1,1,1], [0,0,0,0]],
	rotations : 4,
	color : { r:0xcc, g:0x83, b:0x00 }, // Red-Orange
    },
    LongL : {
	shape : [[0,0,0,0], [0,0,0,1], [1,1,1,1], [0,0,0,0]],
	rotations : 4,
	color : { r:0xa0, g:0x00, b:0xff }, // Light BLue
    },
    IL : {
	shape : [[0,0,0,0], [0,0,1,0], [1,1,1,1], [0,0,0,0]],
	rotations : 4,
	color : { r:0xff, g:0xbb, b:0x00 }, // Orange Yellow
    },
    JI : {
	shape : [[0,0,0,0], [0,1,0,0], [1,1,1,1], [0,0,0,0]],
	rotations : 4,
	color : { r:0x98, g:0x68, b:0x08 }, // Yellow Green
    },
    BigS : {
	shape : [[1,0,0], [1,1,1], [0,0,1]],
	rotations : 4,
	color : { r:0x00, g:0xff, b:0x91 }, // Teal
    },
    BigZ : {
	shape : [[0,0,1], [1,1,1], [1,0,0]],
	rotations : 4,
	color : { r:0x00, g:0xbd, b:0xff }, // Cyan-light blue
    },
    JT : {
	shape : [[0,1,0], [1,1,1], [0,0,1]],
	rotations : 4,
	color : { r:0x00, g:0x91, b:0xff }, // Lighter Blue
    },
    TL : {
	shape : [[0,1,0], [1,1,1], [1,0,0]],
	rotations : 4,
	color : { r:0xff, g:0x00, b:0x83 }, // Dark Orange
    },
    LongS : {
	shape : [[0,0,0,0], [0,0,1,1], [1,1,1,0], [0,0,0,0]],
	rotations : 4,
	color : { r:0x00, g:0x80, b:0x80 }, // Purple
    },
    LongZ : {
	shape : [[0,0,0,0], [1,1,0,0], [0,1,1,1], [0,0,0,0]],
	rotations : 4,
	color : { r:0xff, g:0x57, b:0x00 }, // Fuscia
    },
    P : {
	shape : [[0,0,0], [1,1,0], [1,1,1]],
	rotations : 4,
	color : { r:0x4c, g:0x00, b:0x99 }, // Brown
    },
    b : {
	shape : [[0,0,0], [0,1,1], [1,1,1]],
	rotations : 4,
	color : { r:0x6B, g:0x49, b:0x04 }, // Lime
    },
    BigL : {
	shape : [[1,0,0], [1,0,0], [1,1,1]],
	rotations : 4,
	color : { r:0x5C, g:0x5C, b:0x5C }, // Dark Grey
    },
    W : {
	shape : [[0,0,1], [0,1,1], [1,1,0]],
	rotations : 4,
	color : { r:0x00, g:0x00, b:0x99 }, // Tan
    },
    Plus : {
	shape : [[0,1,0], [1,1,1], [0,1,0]],
	rotations : 1,
	color : { r:0xa0, g:0xff, b:0x00 }, // Dark Cyan
    },
    U : {
	shape : [[0,0,0], [1,0,1], [1,1,1]],
	rotations : 4,
	color : { r:0xAA, g:0xDD, b:0x77 }, // Light Grey
    },
    LongI : {
	shape : [[0,0,0,0,0], [0,0,0,0,0], [1,1,1,1,1], [0,0,0,0,0], [0,0,0,0,0]],
	rotations : 2,
	color : { r:0x99, g:0x00, b:0x00 }, // Dark Green
    },
    BigT : {
	shape : [[0,1,0], [0,1,0], [1,1,1]],
	rotations : 4,
	color : { r:0x00, g:0x66, b:0x00 }, // Light Green
    },

    // Triominoes
    SmallL : {
	shape : [[0,1], [1,1]],
	rotations : 4,
	color : { r:0xC0, g:0xC0, b:0xC0 }, // Pink
    },
    SmallI : {
	shape : [[0,0,0], [1,1,1], [0,0,0]],
	rotations : 2,
	color : { r:0xA1, g:0x12, b:0x12 }, // Dark Red
	
    },

    // Diominoe
    TinyI : {
	shape : [[0,0], [1,1]],
	rotations : 1,
	color : { r:0xFF, g:0x66, b:0xB2 }, // Dark Blue
	
    },

    // Monominoe
    Dot : {
	shape : [[1]],
	rotations : 1,
	color : { r:0xDA, g:0xBB, b:0x7E }, // Dark Purple
    },
};

// Game dimensions
const game_width   = 10
const game_height  = 20;
const square_size  = 20;
const top_buffer   = 5; // Space for spawning new blocks
const left_buffer  = 7; // Space for next block
const right_buffer = 7; // Space for next block
const game_border  = 1; // Border width around play area

const startingBlocks = ['I', 'L', 'J', 'T'];

const canvas 	   = document.getElementById("canvas");
const ctx    	   = canvas.getContext("2d");

// Game variables
var array          = [];                   // Play field
var game_active    = false;
var game_paused    = null;
var lines          = 0;
var score          = 0;
var block_upcoming = [];                   // Next chosen blocks
var block_history  = [];                   // History of blocks chosen
var block_pos      = [null, null, null, null]; // Block x, y, rotation, points
var timer          = null;                 // Main loop timer
var animatimer     = [null, null, null];   // Timer for animations
var useExtraPieces = true;
var showGhostBlock = false;
var blockSet       = [];

// Definitions
const UP    = 1;
const RIGHT = 2;
const DOWN  = 3;
const LEFT  = 4;
const DROP  = 5;

// Key Codes
const SPACE  = 32;
const LARROW = 37;
const UARROW = 38;
const RARROW = 39;
const DARROW = 40;
const i_key  = 73;
const j_key  = 74;
const k_key  = 75;
const l_key  = 76;
const n_key  = 78;
const e_key  = 69;
const g_key  = 71;
const p_key  = 80;

const EMPTY = -2;
const WALL  = -1;
var colors = [];

// Rules
const lineScores = [null, 40, 100, 300, 1200, 2600]; // score value per lines cleared
const base_speed = 1000;
const speedup_multiplier = .8;

function isGameOver(){
    for (var y=0; y<5; y++){
	for (var x=0; x<array[y].length; x++){
	    if (array[y][x] != EMPTY){
		return true;
	    }
	}
    }

    return false;
}

function clearAndShift(l){
    for (var i=l.length-1; i>=0; i--){
	var y = l[i];
	for (var y2=y; y2>=top_buffer; y2--){
	    for (var x=0; x<game_width; x++){
		array[y2][x] = array[y2-1][x];
	    }
	}
    }

    redraw();
    main_loop();
}

function animateLineClear(l, n){
    clearTimeout(timer);
    clearAnimationTimer(1)

    if (n > 0){
	for (var i=0; i<l.length; i++){
	    drawBlock(ctx,
		      [[1,1,1,1,1,1,1,1,1,1]],
		      left_buffer + game_border,
		      l[i],
		      0,
		      [block_defs.L.color, block_defs.S.color][n%2]
		     )
	}
	animatimer[1] = setTimeout(function() { animateLineClear(l, n-1) }, 15);
    } else {
	clearAndShift(l);
    }
}

function lookForLines(){
    var lines_cleared = [];
    for (var y=array.length-1; y>top_buffer; y--){
	// Look at line
	var lineFull = true;
	for (var x=0; x<game_width; x++){
	    if (array[y][x] == EMPTY){
		lineFull = false;
		break;
	    }
	}

	// If full lines exist, start animation
	if (lineFull == true){
	    lines_cleared.push(y);
	}
    }

    if (lines_cleared.length > 0)
	animateLineClear(lines_cleared, 8);

    return lines_cleared.length;
}

function placeBlock(block, pos){
    var pos_x = pos[0];
    var pos_y = pos[1];
    var rot   = pos[2];
    var block_number = block_history.length-1;

    block = rotateArray(block, rot);

    for (var y=0; y<block.length; y++) {
	for (var x=0; x<block[y].length; x++) {
	    if (block[y][x] == 1) {
		array[pos_y + y][pos_x + x] = block_number;
	    }
	}
    }
}

function canMove(block_array, pos, dir){
    var pos_x = pos[0];
    var pos_y = pos[1];
    var rot   = pos[2];

    // Move position
    if (dir == DOWN)  pos_y++;
    if (dir == LEFT)  pos_x--;
    if (dir == RIGHT) pos_x++;
    if (dir == UP)    rot++;

    // Rotate
    var block_array = rotateArray(block_array, rot);

    for (var y=0; y<block_array.length; y++) {
	for (var x=0; x<block_array[y].length; x++) {
	    if (block_array[y][x] == 1){
		// Check for out of bounds
		if (pos_x + x < 0 || pos_x + x >= game_width)
		    return false;
		if (pos_y + y >= game_height + top_buffer)
		    return false;
		// Compare against game array
		if (array[pos_y + y][pos_x + x] != EMPTY)
		    return false;
	    }
	}
    }

    // Can move!
    return true;
}

function isAnimating(){
    for (var i=0; i<animatimer.length; i++)
	if (animatimer[i] != null) return true;
    return false;
}

function clearAnimationTimer(n=-1){
    // Clear all timers
    if (n == -1) {
	for (var i=0; i<animatimer.length; i++){
	    clearTimeout(animatimer[i]);
	    animatimer[i] = null;
	}
    } else {
	clearTimeout(animatimer[n]);
	animatimer[n] = null;
    }
}

function animateDrop(block_array){
    clearTimeout(timer);
    clearAnimationTimer(3);

    if (canMove(block_array, block_pos, DOWN) == true){
	move(DOWN);
	block_pos[3] += 1; // Bonus point per square for dropping fast
	animatimer[3] = setTimeout(function() { animateDrop(block_array) }, 5);
    } else {
	main_loop();
    }
}

function move(dir){
    // Get shape template
    var block_array = block_history[block_history.length-1].shape;

    // Is valid move?
    if (canMove(block_array, block_pos, dir) == false)
	return;

    // Actually move block
    if (dir == DOWN){
	block_pos[1] = block_pos[1] + 1;
	block_pos[3] += 1 // Get point per step for slow dropping
    }

    if (dir == DROP){
	block_pos[3] = 0; // only get points from where it was fast dropped
	animateDrop(block_array);
    }

    if (dir == LEFT){
	block_pos[3] = 0; // only get points for how far it dropped without shifting
	block_pos[0] = block_pos[0] - 1;
    }

    if (dir == RIGHT){
	block_pos[3] = 0; // only get points for how far it dropped without shifting
	block_pos[0] = block_pos[0] + 1;
    }

    if (dir == UP){
	block_pos[3] = 0; // only get points for how far it dropped without shifting
	block_pos[2] = block_pos[2] + 1;
    }

    // Redraw
    redraw();
}

function toggleGhostMode(){
    if (showGhostBlock == true)
	showGhostBlock = false;
    else
	showGhostBlock = true;
    drawGameInformation();
}

function toggleExtraPieces(){
    if (useExtraPieces == true)
	useExtraPieces = false;
    else
	useExtraPieces = true;
    drawGameInformation();
}

function user_move(e){
    if (game_active == false && e.keyCode == n_key)
	start();

    if (e.keyCode == g_key)
	toggleGhostMode();

    if (game_active == false && e.keyCode == e_key)
	toggleExtraPieces();

    if (game_active == true && e.keyCode == p_key)
	togglePause();

    if (game_active == true && isAnimating() == false && game_paused == false) {
	var direction = null;
	switch(e.keyCode){
	case SPACE:
	    direction = DROP;
	    break;
	case LARROW:
	case j_key:
	    direction = LEFT;
	    break;
	case UARROW:
	case i_key:
	    direction = UP;
	    break;
	case RARROW:
	case l_key:
	    direction = RIGHT;
	    break;
	case DARROW:
	case k_key:
	    direction = DOWN;
	    break;
	default:
	    return;
	}
	move(direction);
    }
}

function currentLevel(){
    return Math.floor(lines/10) + 1;
}

function main_loop(){
    // See if we are paused
    if (game_paused == true) return;

    // See if animations are going, and wait for them to finish
    if (isAnimating() == true) return;

    // Get shape template
    var block_array = block_history[block_history.length-1].shape;

    // See if a block has been placed
    if (canMove(block_array, block_pos, DOWN) == false){
	// Add block array to array
	placeBlock(block_array, block_pos);

	// Look for lines to clear, Update Scores and Counts
	var lines_cleared = lookForLines();
	score += lineScores[lines_cleared] * currentLevel();
	lines += lines_cleared;

	// 1 point per block for distance fallen, double for fast drop
	score += block_pos[3] > 40 ? 40 : block_pos[3];

	// See if game is over
	if (isGameOver() == true){
	    clearTimeout(timer);
	    clearAnimationTimer();
	    game_active = false;
	    textOverlay([["40px SegmentedAlpha","GAME OVER"],["20px Arial","Click to play again!"]]);
	    return;
	}

	// Animate blocks scrolling up
	animateUpcomingBlocks(0);
    }

    // Move current block down
    move(DOWN);

    // See if window/game lost focus, and pause
    //if (document.activeElement == document.getElementById('myInput')) // Not working
    if(!document.hasFocus()) pause();

    // Set timeout for next cycle
    speed = base_speed * Math.pow(speedup_multiplier, currentLevel() -1);
    timer = setTimeout(function() { main_loop() }, speed);
}

function shuffle(array) {
    let counter = array.length;

    // While there are elements in the array
    while (counter > 0) {
        // Pick a random index
        let index = Math.floor(Math.random() * counter);

        // Decrease counter by 1
        counter--;

        // And swap the last element with it
        let temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }

    return array;
}

function add_block(){
    // Make sure first block of game is from more restrictive set
    if (block_upcoming.length == 0){
	var t = startingBlocks[Math.floor(Math.random() * startingBlocks.length)];
	block_upcoming.push(block_defs[t]);
    }

    // If there are fewer than 8 pieces, add a whole set of pieces in random order
    while (block_upcoming.length < 8){
	for (var t of shuffle(blockSet))
	     block_upcoming.push(block_defs[t]);
    }

    // Move next block from block_upcoming array to block_history array
    block_history.push(block_upcoming[0]);
    block_upcoming = block_upcoming.slice(1);

    // Set position of previous 'next' block to top, center
    var this_block = block_history[block_history.length-1];
    block_pos = [(game_width/2) - 1,
		 top_buffer - this_block.shape.length,
		 0,
		 0];

}

function clearScreen(){
    // Setup Game field
    var total_height = game_height + top_buffer + game_border;
    var total_width  = game_width + left_buffer + right_buffer + (2*game_border);
    canvas.height = square_size * (total_height);
    canvas.width  = square_size * (total_width);

    // Setup Array
    array = [];
    for (var y=0; y<game_height+top_buffer; y++){
	var temp = [];
	for (var x=0; x<game_width; x++){
	    temp.push(EMPTY);
	}
	array.push(temp);
    }

    redraw();
    return;
}

function setFocus(){
    document.getElementById("myInput").focus()
}


function pause(){
    if (game_active == true && game_paused == false){
	game_paused = true;
	textOverlay([["48px SegmentedAlpha","PAUSED"],["20px Arial","Click to resume."]]);
	clearTimeout(timer);
    }
}

function unpause(){
    if (game_active == true && game_paused == true){
    	game_paused = false;
	main_loop();
    }
}

function togglePause(){
    if (game_active == true){
	if (game_paused == false){
	    pause();
	} else {
	    unpause();
	}
    }
}

function start(){
    setFocus();    // Set focus to input box
    togglePause();  // Toggle pause

    // Start game
    if (game_active == false) {
	clearScreen();      // Clear the screen
	lines = 0;
	score = 0;
	block_history = [];
	block_upcoming = []; // Clear next blocks
	// Set which type of blocks for game
	blockSet = ['I', 'L', 'J', 'T', 'S', 'Z', 'O'];
	if (useExtraPieces == true)
	    blockSet = Object.keys(block_defs);
        add_block();         // Populate upcoming blocks
	redraw();            // Draw the screen
	game_active = true;
	game_paused = false;
	main_loop();
    }
}

function drawUpcomingBlocks(offset=0){
    for (var i=0; i<7; i++){
	var next_block = block_upcoming[i];
	var next_block_height = next_block.shape.length;
	var next_block_width = next_block.shape[0].length;
	var next_block_left = Math.floor((left_buffer / 2) - (next_block_width / 2));
	drawBlock(ctx,
		  next_block.shape,
		  next_block_left,
		  top_buffer - next_block_height + (4 * i) + offset,
		  0,
		  next_block.color);
    }
}

function animateUpcomingBlocks(n){
    clearTimeout(timer);
    clearAnimationTimer(2);

    // Clear left section
    ctx.fillStyle = "#222222";
    ctx.fillRect(0, 0, left_buffer * square_size, canvas.height);

    if (n > -5){
	drawUpcomingBlocks(n);
	n--;
	animatimer[2] = setTimeout(function() { animateUpcomingBlocks(n) }, 20);
    } else {
	add_block(); // Add a block
	main_loop(); // Kickstart loop again 
    }
}

function redrawGameField(){
    for (var y=0; y<array.length; y++){
	for (var x=0; x<array[y].length; x++){
	    if (array[y][x] == EMPTY) continue;
	    drawChisledBrick(ctx, x + left_buffer + game_border, y, square_size,
			     block_history[array[y][x]].color,
			     y > 0                 ? array[y][x] == array[y-1][x] : false,
			     x < array[0].length-1 ? array[y][x] == array[y][x+1] : false,
			     y < array.length-1    ? array[y][x] == array[y+1][x] : false,
			     x > 0                 ? array[y][x] == array[y][x-1] : false,
			    );
	}
    }
}

function redraw(){
    // Draw black background
    ctx.fillStyle = "#222222";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#000000";
    ctx.fillRect((left_buffer + game_border)*square_size, 0, game_width*square_size, canvas.height);

    // Draw border around game field
    for (var y=0; y<=game_height + game_border; y++)
	for (var x=0; x<game_width + (2 * game_border); x++)
	    if (y == game_height || (x == 0 || x == game_width + 1))
		drawChisledBrick(ctx, x + left_buffer, y + top_buffer, square_size,
				 {r:0x88, g:0x88, b:0x88},
				 y == 0 || y == game_height && x != 0 && x != game_width + 1 ? false : true,
				 y < game_height || y == game_height && x == game_width + 1 ? false : true,
				 y == game_height ? false : true,
				 y < game_height || y == game_height && x == 0 ? false : true,
				);

    // Draw each block in game field
    redrawGameField();

    if (game_active == false) return;

    // Draw upcoming blocks
    drawUpcomingBlocks();

    // Draw current block
    var this_block        = block_history[block_history.length-1];

    // Ghost block
    if (showGhostBlock == true){
	// Get lowest it can go
	var ghost_pos = block_pos.slice();
	while (canMove(this_block.shape, ghost_pos, DOWN) == true)
	    ghost_pos[1]++;
	drawBlockInGameField(ctx, this_block.shape, block_pos[0], ghost_pos[1], block_pos[2], this_block.color, 2, true);
    }

    // Draw current block last so it's always on top
    drawBlockInGameField(ctx, this_block.shape, block_pos[0], block_pos[1], block_pos[2], this_block.color);

    drawGameInformation();
}

function drawGameInformation(){
    // Clear section
    // Draw black background
    ctx.fillStyle = "#222222";
    ctx.fillRect(canvas.width-(right_buffer*square_size), 0, right_buffer*square_size, canvas.height);
    
    var ralign = canvas.width - (square_size * 1);

    // Draw game information
    var y = top_buffer * square_size + 18;
    ctx.textAlign = "right";
    ctx.fillStyle = "#CCCCCC";
    ctx.font = "18px Arial";
    ctx.fillText("Score",	 ralign, y);
    ctx.fillText("Lines",	 ralign, y+60);
    ctx.fillText("Level",	 ralign, y+120);
    ctx.fillText("Extra Pieces",	 ralign, y+180);
    ctx.fillText("Ghost Block",	 ralign, y+240);
    ctx.fillStyle = "#00CC00";
    ctx.font = "28px Segmented";
    ctx.fillText(score,		 ralign, y+30);
    ctx.fillText(lines,		 ralign, y+90);
    ctx.fillText(currentLevel(), ralign, y+150);
    ctx.font = "24px SegmentedAlpha";
    ctx.fillText(useExtraPieces== true ? "Enabled" : "Disabled", ralign, y+210);
    ctx.fillText(showGhostBlock == true ? "Enabled" : "Disabled", ralign, y+270);

    // Draw settings

    // Draw help information
    y = canvas.height - square_size - 10
    ctx.fillStyle = "#CCCCCC";
    ctx.font = "Italic 11px Arial";
    ctx.fillText("(n) New Game",       ralign, y-72);
    ctx.fillText("(arrows) Move",       ralign, y-60);
    ctx.fillText("(up arrow) Rotate",   ralign, y-48);
    ctx.fillText("(space) Drop",        ralign, y-36);
    ctx.fillText("(p) Pause",           ralign, y-24);
    ctx.fillText("(e) Extra Pieces",    ralign, y-12);
    ctx.fillText("(g) Ghost Mode",      ralign, y-0);

}

function rotateArray(a, n){
    rotated = a.slice(); // Copies the array
    
    for (var rotate=0; rotate<n; rotate++){
	// Create new array of the same size
	var tmp = [];
	for (var y=0; y<a.length; y++){
	    var t_row = [];
	    for (var x=0; x<a[y].length; x++){
		t_row.push(0);
	    }
	    tmp.push(t_row);
	}
	
	// Copy data to new, empty array
	for (var y=0; y<a.length; y++){
	    for (var x=0; x<a[y].length; x++){
		tmp[y][x] = rotated[x][a.length-y-1];
	    }
	}

	// Overwrite rotated array
	rotated = tmp.slice();
    }
    return rotated;
}

function drawBlockInGameField(ctx, def, bx, by, r, c, edge=-1, outline=false){
    // offset so it draws on the game board
    drawBlock(ctx, def, left_buffer + game_border + bx, by, r, c, edge, outline);
}

function drawBlock(ctx, def, bx, by, r, c, edge=-1, outline=false){
    // rotate block array
    var block = rotateArray(def, r);;
    var width = def[0].length;
    var height = def.length;

    for (var y=0; y<height; y++){
	for (var x=0; x<width; x++){
	    if (block[y][x] == 1){
		drawChisledBrick(ctx,
				 (bx + x),
				 (by + y),
				 square_size,
				 c,
				 y > 0                 ? block[y][x] == block[y-1][x] : false,
				 x < block[0].length-1 ? block[y][x] == block[y][x+1] : false,
				 y < block.length-1    ? block[y][x] == block[y+1][x] : false,
				 x > 0                 ? block[y][x] == block[y][x-1] : false,
				 edge,
				 outline,
				)
	    }
	}
    }
    
}

function shiftColor(c, d){
    var r = c.r - d;
    var g = c.g - d;
    var b = c.b - d;

    r = r < 0 ? 0 : r;
    g = g < 0 ? 0 : g;
    b = b < 0 ? 0 : b;
    r = r > 0xff ? 0xff : r;
    g = g > 0xff ? 0xff : g;
    b = b > 0xff ? 0xff : b;

    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

function drawChisledBrick(ctx, x, y, l, c, n, e, s, w, edge=-1, outline=false){
    if (edge < 0)
	edge = Math.floor(square_size * .25);

    // Adjust x, y coordinates
    x *= l;
    y *= l;

    // Define colors
    var c_lightest = shiftColor(c, -0x64);;
    var c_light    = shiftColor(c, -0x32);
    var c_normal   = shiftColor(c, 0x0);
    var c_dark     = shiftColor(c, 0x32);
    var c_darkest  = shiftColor(c, 0x64);
    if (outline == true){
	var c_lightest = shiftColor(c, 0x0);
	var c_light    = shiftColor(c, 0x0);
	var c_normal   = "rgba(0,0,0,0)";
	var c_dark     = shiftColor(c, 0x0);
	var c_darkest  = shiftColor(c, 0x0);
    }

    // Fill in background color
    ctx.fillStyle = c_normal;
    ctx.fillRect(x, y, l, l);

    // North Edge
    if (n == false){
	ctx.beginPath();
	ctx.moveTo(x, y);
	if (w == true)
	    ctx.lineTo(x, y+edge);
	else
	    ctx.lineTo(x+edge, y+edge);
	if (e == true)
	    ctx.lineTo(x+l, y+edge);
	else
	    ctx.lineTo(x+l-edge, y+edge);
	ctx.lineTo(x+l, y);
	ctx.fillStyle = c_lightest;
	ctx.fill();
    }

    // West Edge
    if (w == false){
	ctx.beginPath();
	ctx.moveTo(x, y);
	if (n == true)
	    ctx.lineTo(x+edge, y);
	else
	    ctx.lineTo(x+edge, y+edge);
	if (s == true)
	    ctx.lineTo(x+edge, y+l);
	else
	    ctx.lineTo(x+edge, y+l-edge);
	ctx.lineTo(x, y+l);
	ctx.fillStyle = c_light;
	ctx.fill();
    }

    // East Edge
    if (e == false){
	ctx.beginPath();
	ctx.moveTo(x+l, y);
	if (n == true)
	    ctx.lineTo(x+l-edge, y);
	else
	    ctx.lineTo(x+l-edge, y+edge);
	if (s == true)
	    ctx.lineTo(x+l-edge, y+l);
	else
	    ctx.lineTo(x+l-edge, y+l-edge);
	ctx.lineTo(x+l, y+l);
	ctx.fillStyle = c_dark;
	ctx.fill();
    }

    // South Edge
    if (s == false){
	ctx.beginPath();
	ctx.moveTo(x, y+l);
	if (w == true)
	    ctx.lineTo(x, y+l-edge);
	else
	    ctx.lineTo(x+edge, y+l-edge);
	if (e == true)
	    ctx.lineTo(x+l, y+l-edge);
	else
	    ctx.lineTo(x+l-edge, y+l-edge);
	ctx.lineTo(x+l, y+l);
	ctx.fillStyle = c_darkest;
	ctx.fill();
    }

    // NW Corner
    if (n == true && w == true){
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+edge, y);
        ctx.lineTo(x+edge, y+edge);
        ctx.fillStyle = c_light;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y+edge);
        ctx.lineTo(x+edge, y+edge);
        ctx.fillStyle = c_lightest;
        ctx.fill();
    }

    // NE Corner
    if (n == true && e == true){
        ctx.beginPath();
        ctx.moveTo(x+l, y);
        ctx.lineTo(x+l-edge, y);
        ctx.lineTo(x+l-edge, y+edge);
        ctx.fillStyle = c_dark;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x+l, y);
        ctx.lineTo(x+l, y+edge);
        ctx.lineTo(x+l-edge, y+edge);
        ctx.fillStyle = c_lightest;
        ctx.fill();
    }

    // SW Corner
    if (s == true && w == true){
        ctx.beginPath();
        ctx.moveTo(x, y+l);
        ctx.lineTo(x+edge, y+l);
        ctx.lineTo(x+edge, y+l-edge);
        ctx.fillStyle = c[3];
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x, y+l);
        ctx.lineTo(x, y+l-edge);
        ctx.lineTo(x+edge, y+l-edge);
        ctx.fillStyle = c_darkest;
        ctx.fill();
    }

    // SE Corner
    if (s == true && e == true){
        ctx.beginPath();
        ctx.moveTo(x+l, y+l);
        ctx.lineTo(x+l-edge, y+l);
        ctx.lineTo(x+l-edge, y+l-edge);
        ctx.fillStyle = c_dark;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x+l, y+l);
        ctx.lineTo(x+l, y+l-edge);
        ctx.lineTo(x+l-edge, y+l-edge);
        ctx.fillStyle = c_darkest;
        ctx.fill();
    }
}

function textOverlay(string_array){
    ctx.fillStyle = "rgba(0,0,0,.5)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "center";
    var y = canvas.height/2;
    for (var i=0; i<string_array.length; i++){
	ctx.font = string_array[i][0];
	ctx.fillText(string_array[i][1], canvas.width/2, y);
	y += 32;
    }
}

clearScreen();
drawGameInformation();
textOverlay([["32px SegmentedAlpha","Click to start!"]]);

    </script>
  </body>
</html>
