<html class=" nyfjjn idc0_343 pgryvpe"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Snake</title>
    <style>
      body {
          background:#aaa;
          color:#000;
          font-family:sans-serif;
      }

      div#content {
          width: 362px;
          background:#fff;
          margin: 0 auto 0 auto;
          padding:15px 15px 30px 15px;
      }

      #canvas_wrapper {
	  position: relative;
	  width: 360px;
	  height: 360px;
      }

      canvas {
	  position: absolute;
	  top: 0px;
	  left: 0px;
      }

      h1 {
          margin:10px;
          font-size:3em;
      }

      #header {
          text-align:left;
      }


      #debug {
	  display: none;
	  background: #eee;
	  text-align: left;
	  border-radius: 15px;
	  margin: 10px;
	  width: fit-content;
	  padding: 5px 30px;      
      }

      input {
	  max-width: 40px;
      }

      #speed {
	  max-width: 250px;
      }

      #score_container{
	  float: right;
	  margin-top: -30px;
      }

      dl {
	  display:flex;
	  flex-flow: row wrap;
	  width:300px;
      }

      dt{
	  flex-basis:40%;
	  text-align: right;
      }

      dd {
	  flex-basis:40%;
	  flex-grow: 1;
	  text-align: left;
	  margin: 2px 5px;
      }

      table {
	  border: 0px;
      }

      .score {
	  text-align: right;
      }

      .date {
	  font-style: italic;
	  font-size: .8em;
      }
    </style>
  </head>
  <body>
    <div id="content">
      <div id="header">
	<h1>Snake</h1>
      </div>

      <div id="canvas_wrapper">
	<canvas id="background" style="border:1px solid black;" width="360" height="360"></canvas>
	<canvas id="canvas" style="border:1px solid black;" width="360" height="360"></canvas>
      </div>

    <p><button onclick="new_game();">New Game</button>
    <select id="numplayers">
	  <option value="1">One Player</option>
	  <option value="2" selected="selected">Two Player</option>
	  <option value="3">Three Player</option>
	  <option value="4">Four Player</option>
      </select></p>

      <h2>Player 1</h2>
      <p>
        Score: <span id="score1">0</span><br>
        Controls: Arrows<br>
        Player 1 Color: <select id="color1">
	  <option value="0" selected="selected">Green</option>
	  <option value="1">Blue</option>
	  <option value="2">Grey</option>
	  <option value="3">Red</option>
	  <option value="4">Yellow</option>
      </select></p>
      <h2>Player 2</h2>
      <p>
        Score: <span id="score2">0</span><br>
        Controls: I, J, K, and L<br>
        Player 2 Color: <select id="color2">
	  <option value="0">Green</option>
	  <option value="1" selected="selected">Blue</option>
	  <option value="2">Grey</option>
	  <option value="3">Red</option>
	  <option value="4">Yellow</option>
      </select></p>
      <h2>Player 3</h2>
      <p>
        Score: <span id="score3">0</span><br>
        Controls: W, A, S, and D<br>
        Player 3 Color: <select id="color3">
	  <option value="0">Green</option>
	  <option value="1">Blue</option>
	  <option value="2">Grey</option>
	  <option value="3">Red</option>
	  <option value="4" selected="selected">Yellow</option>
      </select></p>
      <h2>Player 4</h2>
      <p>
        Score: <span id="score4">0</span><br>
        Controls: Number Pad (8, 4, 5, and 6)<br>
        Player 4 Color: <select id="color4">
	  <option value="0">Green</option>
	  <option value="1">Blue</option>
	  <option value="2">Grey</option>
	  <option value="3" selected="selected">Red</option>
	  <option value="4">Yellow</option>
      </select></p>

      <h2>Credits</h2>
      <p>The snake sprites were created by <a href="http://www.sledd.com/">John Sledd</a> for a video game called Slithereens, by the now-defunct <a href="https://en.wikipedia.org/wiki/Ambrosia_Software">Ambrosia Software</a>. I am using these graphics without express permission from the original IP holder. You can read about decoding the sprites on <a href="https://porkrind.org/missives/decoding-the-sprite-format-of-a-25-year-old-game/">my bother's blog</a>.</p><!--'-->

    <div id="debug">
	<h2>DEBUG</h2>
	<p>Pixel Pos x:<span id="pix_x">48</span>, y:<span id="pix_y">0</span><br>
	  Grid Pos x:<span id="grid_x">2</span>, y:<span id="grid_y">0</span><br>
	  <button onclick="next_frame(true);">Advance Frame</button><button onclick="next_frame();">Continue</button><br>
	  Width:<input id="width" value="15">Height:<input id="height" value="15"><br>
	  Speed:<input id="speed" oninput="change_speed();" type="range" min="1" max="500" value="10">
	</p>
      </div>

    </div>
  
  <script>

const WEST  = 0;
const NORTH = 1;
const EAST  = 2;
const SOUTH = 3;

const HEAD = 0;
const BODY = 1;

const ALIVE = 2;
const DYING = 1;
const DEAD  = 0;

const sprite = new Image();
sprite.src = "sprites.png";
const apple = new Image();
apple.src = "apple.png";

let direction;
let active;
let snack = null;
let speed;
let timer;
let paused = true;
let gridsize = 24;
let width = 15;
let height = 15;
let fast = false;
let players = 2;

// Keyboard listeners
document.addEventListener('keydown', function(e) {
    //console.log(e);

    // Arrows
    if (e.keyCode == 38) {e.preventDefault(); paused = false; player_1.direction = NORTH};
    if (e.keyCode == 39) {e.preventDefault(); paused = false; player_1.direction = EAST};
    if (e.keyCode == 40) {e.preventDefault(); paused = false; player_1.direction = SOUTH};
    if (e.keyCode == 37) {e.preventDefault(); paused = false; player_1.direction = WEST};

    // IJKL
    if (e.keyCode == 73) {e.preventDefault(); paused = false; player_2.direction = NORTH};
    if (e.keyCode == 76) {e.preventDefault(); paused = false; player_2.direction = EAST};
    if (e.keyCode == 75) {e.preventDefault(); paused = false; player_2.direction = SOUTH};
    if (e.keyCode == 74) {e.preventDefault(); paused = false; player_2.direction = WEST};

    // WASD
    if (e.keyCode == 87) {e.preventDefault(); paused = false; player_3.direction = NORTH};
    if (e.keyCode == 68) {e.preventDefault(); paused = false; player_3.direction = EAST};
    if (e.keyCode == 83) {e.preventDefault(); paused = false; player_3.direction = SOUTH};
    if (e.keyCode == 65) {e.preventDefault(); paused = false; player_3.direction = WEST};

    // 8456
    if (e.keyCode == 104) {e.preventDefault(); paused = false; player_4.direction = NORTH};
    if (e.keyCode == 102) {e.preventDefault(); paused = false; player_4.direction = EAST};
    if (e.keyCode == 101) {e.preventDefault(); paused = false; player_4.direction = SOUTH};
    if (e.keyCode == 100) {e.preventDefault(); paused = false; player_4.direction = WEST};

    if (e.keyCode == 78) start();            // n
    if (e.keyCode == 80) toggle_pause();     // p
    if (e.keyCode == 32) {e.preventDefault(); fast = true;} // shift
});

document.addEventListener('keyup', function(e) {
    if (e.keyCode == 32) fast = false;
});

function new_snack(){
    let valid = false;
    let x;
    let y;

    // Cheat
    /*
    x = snake[0].x;
    y = snake[0].y;
    if (snake[0].d == NORTH)
	y -= 30;
    if (snake[0].d == EAST)
	x += 30;
    if (snake[0].d == SOUTH)
	y += 30;
    if (snake[0].d == WEST)
	x -= 30;

    if (x > (width-1) * gridsize || y > (height-1) * gridsize || x < 5 || y < 5)
	valid = false;
    else
	valid = true;
    */

    while (valid == false){
	valid = true;
        x = Math.floor(Math.random() * (width-1) * gridsize);
        y = Math.floor(Math.random() * (height-1) * gridsize);

        /*
	for (let segment of snake){
	    if (collided({x:x, y:y}, segment, 15)){
		valid = false;
		break;
	    }
	    }
            */
    }
    return {x:x, y:y};
}

function generate_background(c){
    let ctx = c.getContext("2d");

    // Draw random brown to represent dirt
    for (let x=0; x<c.width; x++)
	for (let y=0; y<c.height; y++){
	    ctx.fillStyle = "hsla(24,100%,"+(Math.floor(Math.random()*8)+13)+"%,1)";
	    ctx.fillRect(x, y, 1, 1);
	}
}

function setup_canvas(){
    width = Number(document.getElementById("width").value);
    height = Number(document.getElementById("height").value);

    let c = document.getElementById("canvas");
    c.width = gridsize * width;
    c.height = gridsize * height;

    let b = document.getElementById("background");
    b.width = gridsize * width;
    b.height = gridsize * height;

    generate_background(b);
}

function update_color(){
    color = Number(document.getElementById("color").value);
}

function toggle_pause(){
    if (paused){
	paused = false;
    } else {
	paused = true;
    }
}

function change_speed(){
    let input = 500-Number(document.getElementById("speed").value);
    speed = Math.sqrt(input) * Math.pow(.9, snake.length-2);
}

function collided(a, b, tolerance){
    if (a.x > b.x - tolerance && a.x < b.x + tolerance &&
        a.y > b.y - tolerance && a.y < b.y + tolerance)
        return true;
    return false;
}

function intersected(snake){
    let head = snake.snake[0];

    // Look for intersections with boundaries
    if (head.x < 0 || head.y < 0 ||
        head.x+gridsize > width*gridsize || head.y+gridsize > height*gridsize){
        return true;
    }

    // Look for intersections with snakes
    if (player_1.status != DEAD)
        for (let s=0; s<player_1.snake.length; s++)
            if (s!=0 || snake.player != player_1.player)
                if (collided(head, player_1.snake[s], 8))
                    return true;

    if (players > 1 && player_2.status != DEAD){
    for (let s=0; s<player_2.snake.length; s++)
        if (s!=0 || snake.player != player_2.player)
            if (collided(head, player_2.snake[s], 8))
                return true;
    }

    if (players > 2 && player_3.status != DEAD) {
    for (let s=0; s<player_3.snake.length; s++)
        if (s!=0 || snake.player != player_3.player)
            if (collided(head, player_3.snake[s], 8))
                return true;
    }

    if (players > 3 && player_4.status != DEAD) {
    for (let s=0; s<player_4.snake.length; s++)
        if (s!=0 || snake.player != player_4.player)
            if (collided(head, player_4.snake[s], 8))
                return true;
    }

    return false;
}

class snake {
    constructor(canvas, color, score, d, x, y, p){
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.player = p;
        this.score_div = score;
        this.color_select = color;

        // Defaults
        this.default_dir = d;
        this.default_head_pos = {x:x, y:y};
        this.default_body_pos = {x:x, y:y};

        switch(this.default_dir){
        case EAST:
            this.default_body_pos.x -= 24;
            break;
        case SOUTH:
            this.default_body_pos.y -= 24;
            break;
        case WEST:
            this.default_body_pos.x += 24;
            break;
        case NORTH:
            this.default_body_pos.y += 24;
            break;
        }

        this.snake = [];
        this.frame = 0;
        this.speed = 0;
        this.direction = d;
        this.status = ALIVE;
    }

    start() {
        this.snake = [
            {x:this.default_head_pos.x, y:this.default_head_pos.y, d:this.default_dir, c:"#ff0000", t:HEAD, m:[], e:0, f:0},
            {x:this.default_body_pos.x, y:this.default_body_pos.y, d:this.default_dir, c:"#00ff00", t:BODY, m:[], p:0, f:1},
        ];

        this.direction = this.default_dir;
        this.status = ALIVE;
        this.frame = 0;
        this.speed = .5;
        this.score_div.innerHTML = "0";
    }

    move() {
        // Every time we move, the frame advances one. Need to have it reset every million or so...
        this.frame++;
        if (this.frame > 1000000) this.frame = 1;

        // If we are dead; don't bother doing anything else
        if (this.status <= DYING){
            if (this.frame % 10 == 0)
                for (let s=0; s<this.snake.length; s++)
                    this.snake[s].f++

            // Move from dying to dead once skeleton animation is complete
            if (this.snake[0].f > 10)
                this.status = DEAD;
            return;
        }

        // Process head eating animation frame
        if (this.snake[0].e > 0)
	    this.snake[0].e-=.25;

        // Eat. Yum.
        if (collided(this.snake[0], snack, 10)){
	    this.snake[0].e = 11.75; // Setup 11 frames of eating animation
            this.snake.push(
	        {
		    x:this.snake[this.snake.length-1].x,  	    // X Pos
		    y:this.snake[this.snake.length-1].y,  	    // Y Pos
		    c:"#00ff00",                	            // Debug
		    d:this.snake[this.snake.length-1].d,  	    // Direction
		    t:BODY,                     	            // Segment Type
		    p:this.snake[this.snake.length-1].p + gridsize, // Pause value
		    m:this.snake[this.snake.length-1].m.slice(),    // Moves
                    f:this.snake[this.snake.length-1].f + 1,        // Frame
	        });

            this.speed += .125
            if (this.speed > 2) this.speed = 2; // Max Speed

            snack = new_snack();
            this.score_div.innerHTML = this.snake.length - 2;
        }

        // Change direction of head
        if (this.snake[0].d % 2 != this.direction %2){
	    // Round the direction that we are traveling so we are on a pixel after turning
	    /*
	    switch (this.snake[0].d){
	    case NORTH:
                this.snake[0].y = Math.floor(this.snake[0].y);
                break;
            case EAST:
                this.snake[0].x = Math.ceil(this.snake[0].x);
                break;
            case SOUTH:
                this.snake[0].y = Math.ceil(this.snake[0].y);
                break;
            case WEST:
                this.snake[0].x = Math.floor(this.snake[0].x);
                break;
	    }
	    */

	    // Update the head's direction
            this.snake[0].d = this.direction;

	    // Add direction instructions for each subsequent segment
	    for (let s=1; s<this.snake.length; s++){
                this.snake[s].m.push({x:this.snake[0].x, y:this.snake[0].y, d:this.direction});
	    }
        }


        // Process subsequent segment
        for (let s=this.snake.length-1; s>0; s--){
            // Can change directions when segment get's to next turn
            // Other segments move towards the segments in front of them
	    if (this.snake[s].m.length > 0){
		if (
		    this.snake[s].d == NORTH && this.snake[s].x == this.snake[s].m[0].x && this.snake[s].y <= this.snake[s].m[0].y ||
		    this.snake[s].d == EAST  && this.snake[s].y == this.snake[s].m[0].y && this.snake[s].x >= this.snake[s].m[0].x ||
		    this.snake[s].d == SOUTH && this.snake[s].x == this.snake[s].m[0].x && this.snake[s].y >= this.snake[s].m[0].y ||
		    this.snake[s].d == WEST  && this.snake[s].y == this.snake[s].m[0].y && this.snake[s].x <= this.snake[s].m[0].x){

		    // Change direction
                    this.snake[s].d = this.snake[s].m[0].d;

		    // Realign to pixel grid
		    this.snake[s].y = this.snake[s].m[0].y;
		    this.snake[s].x = this.snake[s].m[0].x;

		    // Remove from history
		    this.snake[s].m.splice(0, 1);
                }
            }
        }

        // Actually move all the positions if we aren't paused
        if (paused == false && this.status == ALIVE) {
            for (let s=0; s<this.snake.length; s++){
                if (this.snake[s].p > 0)
                    this.snake[s].p-=this.speed;
                else {
                    switch(this.snake[s].d){
                    case NORTH:
                        this.snake[s].y -= this.speed;
                        break;
                    case EAST:
                        this.snake[s].x += this.speed;
                        break;
                    case SOUTH:
                        this.snake[s].y += this.speed;
                        break;
                    case WEST:
                        this.snake[s].x -= this.speed;
                        break;
                    }
                }
            }
        }

        // Update the animation frame
        if (this.frame % 10 == 0)
            for (let s=0; s<this.snake.length; s++)
                if (this.snake[s].f++ >= 13)
                    this.snake[s].f = 0;

        // Check for intersections
        if (intersected(this)){
            this.die();
            return;
        }
    }

    update_color(){
        this.color = this.color_select.value;
    }

    draw(){
        if (this.status == DEAD) return;

        // Draw the snake
        if (this.status == ALIVE)
            this.update_color();

        let color_offset = this.color * 20 * 25;

        let animation_offset = 0;
        for (let s=this.snake.length-1; s>=0; s--){

	    // sx is sprite x offset - Goes left to right, then right to left
	    let sx = this.snake[s].f;
            if (this.status == ALIVE)
	        if (sx >= 7) sx = 13-sx;
	    sx *= 25;

	    // sy is sprite y offset. This is indicative of color and direction
	    let sy = color_offset;

	    if (this.snake[s].t == HEAD){
	        sy += (0  + this.snake[s].d) * 25;

                // Eating animation
	        if (this.snake[s].e >= 1){
		    sy += (25 * 4);
		    sx = (11 - Math.floor(this.snake[s].e)) * 25;
	        }
	    }

	    if (this.snake[s].t == BODY){
                if (this.status == DYING)
                    sy += (4 + this.snake[s].d) * 25;
                else
	            sy += (12 + this.snake[s].d) * 25;
            }

	    this.ctx.drawImage(sprite, sx, sy, 24, 24, this.snake[s].x, this.snake[s].y, 24, 24);
	    animation_offset += 1;

	    // Debug
	    this.ctx.font = "10px Arial";
	    this.ctx.fillText("("+this.snake[s].x+","+this.snake[s].y+")", this.snake[s].x, this.snake[s].y);
        }
    }

    die(){
        this.status = DYING;
	this.color = 5;
        active -= 1;

        // Reset frames for skeleton
        for (let s=0; s<this.snake.length; s++)
            this.snake[s].f = 0;
    }
}

function new_game(){
    //if (active > 0 || paused == false) return;

    clearTimeout(timer);

    if (snack == null)
	snack = new_snack();

    redraw();

    players = document.getElementById("numplayers").value;

    player_1.start();
    player_1.draw();

    if (players > 1){
        player_2.start();
        player_2.draw();
    }
    if (players > 2) {
        player_3.start();
        player_3.draw();
    }
    if (players > 3) {
        player_4.start();
        player_4.draw();
    }

    active = players;
    paused = true;

    next_frame();
}

function next_frame(manual=false){
    redraw();
    player_1.move();
    player_1.draw();

    if (players > 1){
        player_2.move();
        player_2.draw();
    }
    if (players > 2) {
        player_3.move();
        player_3.draw();
    }
    if (players > 3) {
        player_4.move();
        player_4.draw();
    }

    // Setup next animation
    timer = setTimeout(() => next_frame(), 1);
}

function redraw(){
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw snake snack
    ctx.drawImage(apple, 0, 0, 24, 24, snack.x, snack.y, 24, 24);
}

function game_over(){
    active = false;
    //start();
}


setup_canvas();
//update_high_scores();
//start();

let player_1 = new snake(
    canvas,
    document.getElementById("color1"),
    document.getElementById("score1"),
    EAST,
    50,
    50,
    1
);

let player_2 = new snake(
    canvas,
    document.getElementById("color2"),
    document.getElementById("score2"),
    WEST,
    275,
    275,
    2
);

let player_3 = new snake(
    canvas,
    document.getElementById("color3"),
    document.getElementById("score3"),
    SOUTH,
    275,
    50,
    3
);

let player_4 = new snake(
    canvas,
    document.getElementById("color4"),
    document.getElementById("score4"),
    NORTH,
    50,
    275,
    4
);

new_game();
</script>

</body></html>
