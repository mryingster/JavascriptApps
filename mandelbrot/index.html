<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Mandelbrot</title>
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" type="text/css" media="screen" href="style.css">
    <meta charset="utf-8">
  </head>
  <body onresize="resize_canvas();" onload="first_run();">

    <canvas id="canvas" width="1660" height="1085"></canvas>

    <div id="controls">
    <button class="zoom" onclick="zoom(false, null)">-</button>
    <button class="zoom" onclick="zoom(true, null)">+</button>
      Depth:
      <select onchange="render()" id="depthSelection">
        <option>1</option>
        <option>2</option>
        <option>4</option>
        <option>8</option>
        <option>16</option>
        <option selected="selected">32</option>
        <option>64</option>
        <option>128</option>
        <option>256</option>
        <option>512</option>
        <option>1024</option>
        <option>2048</option>
        <option>4096</option>
      </select>
      Scale:
      <select onchange="render()" id="renderScale">
        <option selected="selected">1</option>
        <option>2</option>
        <option>4</option>
        <option>8</option>
      </select>

      <!--
          Center Coordinates:
          <input onchange="recenterFromUserCoords();" class="coord" id="x_coord"></input>,
          <input onchange="recenterFromUserCoords();" class="coord" id="y_coord"></input>
          -->

      <span id="share"><a href="#" id="share_link">Share Link</a></span>
      <span id="download"><a href="#" id="download_link" onclick="save_image();" download="mandelbrot.png">Download PNG</a></span>
    </div>

    <div id="coords_div" class="note">
      Mouse Coordinates: <span id="coords">-0.19854,+1.10112</span>
    </div>

    <div id="elapsed_div" class="note">
      Render Time: <span id="elapsed">00:00.722</span>
    </div>

    <script>

var canvas        = document.getElementById("canvas");
var ctx           = canvas.getContext("2d");
var width         = canvas.width;
var height        = canvas.height;

var view_x_center = 0;
var view_y_center = 0;
var view_width    = 4.5;
var view_height   = 4.5;

var depth         = 10;
var mouse_down    = false;
var mouse_moved   = false;
var start_coord   = null;
var x_diff        = 0;
var y_diff        = 0;

var start_pinch   = null
var pinch         = false;
let start_zoom    = null;

var render_preview = false;
var final_render_timer = null;

// Touch listeners
canvas.addEventListener('touchstart', input_start_touch, false);
canvas.addEventListener('touchmove',  input_move_touch, false);
canvas.addEventListener('touchend',   input_end_touch, false);

function getTouchPosition(canvas, event){
    if (!e)
        var e = event;

    var x_coord = null;
    var y_coord = null;

    let coords=[];

    if(e.touches) {
        for (let i=0; i<e.touches.length; i++){
            let touch = e.touches[i];
            let x_pixel = touch.pageX-touch.target.getBoundingClientRect().left;
            let y_pixel = touch.pageY-touch.target.getBoundingClientRect().top;

            // Determine scale
            const x_scale = view_width / width;
            const y_scale = view_height / height;

            // Update label
            var view_left = view_x_center - (view_width / 2);
            var view_top  = view_y_center - (view_height / 2);
            x_coord = x_pixel * x_scale + view_left;
            y_coord = y_pixel * y_scale + view_top;

            coords.push({x:x_coord, y:y_coord});
        }
    }

    return coords;
}

function input_start_touch(e){
    e.preventDefault();
    let coords = getTouchPosition(canvas, e);

    // Normal scrolling with one finger
    if (coords.length == 1){
        start_coord = coords[0]
        update_coords(start_coord);
        mouse_down = true;
    }

    // Pinching
    if (coords.length == 2){
        start_pinch = coords;
        pinch = true;
        start_zoom = {vw:view_width, vh:view_height};
    }
}

function input_move_touch(e){
    e.preventDefault();

    if (mouse_down == true){
        mouse_moved = true;

        // Get current coords
        let current_coord = getTouchPosition(canvas, e)[0]

	// Find difference
	x_diff = current_coord.x - start_coord.x;
	y_diff = current_coord.y - start_coord.y;

	render();
    }

    if (pinch == true){
        let current_coords = getTouchPosition(canvas, e);

        // If we are down to 1 finger, dont do anything
        if (current_coords.length < 2) return;

        // Find distance between fingers in start and current positions
        let d_start   = Math.abs(Math.hypot(start_pinch[0].x - start_pinch[1].x, start_pinch[0].y - start_pinch[1].y));
        let d_current = Math.abs(Math.hypot(current_coords[0].x - current_coords[1].x, current_coords[0].y - current_coords[1].y));

        // Find how much bigger we should be
        let zoom = d_current / d_start;

        // Maybe guess where we should center eventually?

        // And zoom
        view_width  = start_zoom.vw / zoom;
        view_height = start_zoom.vh / zoom;
        rerender();
    }
}

function input_end_touch(e){
    e.preventDefault();
    input_up_mouse(e);
}


// Mouse listeners
canvas.addEventListener('mousedown',  input_down_mouse);
canvas.addEventListener('mousemove',  input_move_mouse);
canvas.addEventListener('mouseup',    input_up_mouse);
canvas.addEventListener('wheel',      input_wheel);

function input_down_mouse(e){
    start_coord = getCursorPosition(canvas, e);
    mouse_down = true;
}

function input_move_mouse(e){
    if (mouse_down == true){
	mouse_moved = true;
	render_preview = true
	// Get current coords
	let current_coord = getCursorPosition(canvas, e);

 	// Find difference
	x_diff = current_coord.x - start_coord.x;
	y_diff = current_coord.y - start_coord.y;

	render();
    } else {
	update_coords(getCursorPosition(canvas, e));
    }
}

function input_up_mouse(e){
    if (mouse_down == true){
	if (mouse_moved == true) {
	    // Recenter using offsets
	    recenter(
		view_x_center - x_diff,
		view_y_center - y_diff
	    );

	} else {
	    // Recenter to mouse position
	    recenter(
		start_coord.x,
		start_coord.y
	    );
	}

	// Reset offsets
	x_diff = 0;
	y_diff = 0;

	// Stop moving
	mouse_down = false;
	mouse_moved = false;
	render_preview = false;

	// Rerender
	render();
    }
}

function input_wheel(e){
    render_preview = true;
    if (Math.abs(e.deltaY) >= 16) 
    zoom(e.deltaY < 0, getCursorPosition(canvas, e));
}

function update_coords(coords){
    let string = ""
    if (coords.x > 0)
	string += "+"
    string += coords.x.toFixed(5);
    while (string.length < 8)
	string += "0";
    string += ",";
    if (coords.y < 0)
	string += "+"
    string += (-1 * coords.y.toFixed(5));
    while (string.length < 17)
	string += "0";

    document.getElementById("coords").innerHTML = string;
    let url = window.location.href.split('?')[0];
    document.getElementById("share_link").href = url+"?"+coords.x+":"+coords.y;//+":"+"ZOOOOOOM";
}

function render(reset_preview_request = false){
    // Set settings
    depth = Number(document.getElementById("depthSelection").value);
    scale = Number(document.getElementById("renderScale").value);

    // Deal with preview renders
    // Clear existing timeouts (requests for final frames)
    clearTimeout(final_render_timer);

    // If final frame requested, clear the preview flag
    if (reset_preview_request == true){
	render_preview = false;
    }

    // If preview requested...
    if (render_preview == true){
	scale = 8;
	// If there is a render preview request, set a timeout to render actual image after 1/2 second
	if (mouse_down != true){
	    final_render_timer = setTimeout(() => render(true), 250);
	}
    }

    // Start timer
    var start = new Date().getTime();

    // Decide on effective center position
    let effective_x_center = view_x_center - x_diff;
    let effective_y_center = view_y_center - y_diff;

    // Render
    var scaled_x  = view_width / width;
    var scaled_y  = view_height / height;
    var view_left = effective_x_center - (view_width / 2);
    var view_top  = effective_y_center - (view_height / 2);

    // Draw into an offscreen canvas
    let buffer_canvas = new OffscreenCanvas(Math.ceil(width/scale), Math.ceil(height/scale));
    let buffer_ctx    = buffer_canvas.getContext("2d");
    let buffer = buffer_ctx.getImageData(0, 0, buffer_canvas.width, buffer_canvas.height);
    let buffer_index = 0;

    for (var y=0; y<height; y+=scale){
        for (var x=0; x<width; x+=scale){
            var xValue = (x * scaled_x) + (view_left);
            var yValue = (y * scaled_y) + (view_top);
            var result = mandel(xValue, yValue, depth);

            // Choose a color
            var finalColor = "#000000";
            if (result != -1)
                finalColor = chooseColor(result, depth);

            // Draw the pixel too all the pixels necessary
            buffer.data[buffer_index + 0] = finalColor.r; // R
            buffer.data[buffer_index + 1] = finalColor.g; // G
            buffer.data[buffer_index + 2] = finalColor.b; // B
            buffer.data[buffer_index + 3] = 255; // A

            buffer_index += 4;

        }
    }

    // Draw back to the onscreen canvas
    buffer_ctx.putImageData(buffer, 0, 0);
    ctx.drawImage(buffer_canvas,0,0,width,height);

    // End timer
    var duration = (new Date().getTime() - start);
    var minutes = Math.floor(duration/1000/60);
    var seconds = Math.floor(duration/1000) % 60;
    var miliseconds = Math.floor(duration) % 1000;
    if (seconds < 10) { seconds = "0" + seconds; }
    if (minutes < 10) { minutes = "0" + minutes; }
    var duration_string = minutes +":"+ seconds +"."+ miliseconds;
    document.getElementById("elapsed").innerHTML = duration_string;

}

function mandel(x, y, depth){
    // Prime Values
    var xP=0;
    var yP=0;
    // Temporary Values
    var xT=0;
    var yT=0;
    var i=0;

    for (i=0; i<depth; i++)
    {
        xT = (Math.pow(xP, 2)) + x - (Math.pow(yP, 2));
        yT = 2 * xP * yP + y;
        if (Math.pow(Math.abs(xT),2) + Math.pow(Math.abs(yT),2) > 4)
            return i;
        xP = xT;
        yP = yT;
    }
    return -1;
}

function chooseColor(i, d) {
    var r = 0;
    var g = 0;
    var b = 0;

    const band = d / 6;

    if (i >= band * 0 & i < band * 1){
        r = 0xff;
        g = 0xff * i / band;
    }
    if (i >= band * 1 & i < band * 2) {
        g = 0xff;
        r = 0xff * ((band - (i % band)) / band);
    }
    if (i >= band * 2 & i < band * 3) {
        g = 0xff;
        b = 0xff * (i % band) / band;
    }
    if (i >= band * 3 & i < band * 4) {
        b = 0xff;
        g = 0xff * ((band - (i % band)) / band);
    }
    if (i >= band * 4 & i < band * 5) {
        b = 0xff;
        r = 0xff * (i % band) / band;
    }
    if (i >= band * 5 & i < band * 6) {
        r = 0xff;
        b = 0xff * ((band - (i % band)) / band);
    }

    return {r:r, g:g, b:b};
}

function hexString(n) {
    t = Math.floor(n).toString(16)
    if (t.length % 2) {
        t = "0" + t;
    }
    return t;
}

function recenterFromUserCoords(){
    let x = Number(document.getElementById("x_coord").value);
    let y = Number(document.getElementById("y_coord").value);

    recenter(x, y);
}

function recenter(x, y){
    view_x_center = x;
    view_y_center = y;

    //document.getElementById("x_coord").value = x.toFixed(3);
    //document.getElementById("y_coord").value = y.toFixed(3);

    render();
}

function getPixelPosition(canvas, event){
    // Determine pixel location
    const rect = canvas.getBoundingClientRect()
    const x_pixel = event.clientX - rect.left
    const y_pixel = event.clientY - rect.top

    return {x:x_pixel, y:y_pixel};
}
 
function getCursorPosition(canvas, event){
    // Determine pixel location
    const rect = canvas.getBoundingClientRect()
    const x_pixel = event.clientX - rect.left
    const y_pixel = event.clientY - rect.top

    // Determine scale
    const x_scale = view_width / width;
    const y_scale = view_height / height;

    // Update label
    var view_left = view_x_center - (view_width / 2);
    var view_top  = view_y_center - (view_height / 2);
    var x_coord = x_pixel * x_scale + view_left;
    var y_coord = y_pixel * y_scale + view_top;

    return {x:x_coord, y:y_coord};
}

function zoom(zoom_in, coords){
    if (zoom_in == true){
	view_width /= 2;
	view_height /= 2;
        if (coords != null)
            recenter((coords.x - view_x_center) / 2 + view_x_center, (coords.y - view_y_center) / 2 + view_y_center);
        else
            render();
    } else {
	view_width *= 2;
	view_height *= 2;
        if (coords != null)
            recenter(view_x_center - (coords.x - view_x_center), view_y_center - (coords.y - view_y_center));
        else
            render();
    }
}

function resize_canvas(preview = true){
    width  = window.innerWidth;
    height = window.innerHeight;
    canvas.width  = width;
    canvas.height = height;

    // Keep view height the same, but change view width to match aspect ratio
    let t = height / view_height;
    view_width = width / t;

    // Set render_preview to make update faster
    render_preview = preview;

    render();
}

function save_image(){
    document.getElementById("download_link").download = "image.png";
    document.getElementById("download_link").href = canvas.toDataURL("image/png").replace(/^data:image\/[^;]/, 'data:application/octet-stream');
}

function first_run(){
    resize_canvas(false);
    // Check if the URL contains coordinates
    let url = window.location.href;
    if (url.indexOf('?') > -1) {
        let coords = url.split('?')[1];
        let x = coords.split(":")[0];
        let y = coords.split(":")[1];

        recenter(x, y);
    }
}

    </script>
  </body>
</html>
