<!DOCTYPE html>
<html
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Radical</title>
    <style>
    body {
        margin: 0px;
        padding: 0px;
        spacing: 0px;
    }
    </style>
  </head>

  <body onload="first_load()" onresize="">
    <div id="content">
    <canvas id="canvas"></canvas>
    <br>
    <span id="debug"></span>
    </div>
  </body>

  <script>

// comment

class ship{
    constructor(ctx, sprite, sprite_width, sprite_height, scale){
        this.ctx = ctx;
        this.sprite = sprite;
        this.sprite_size = {w:sprite_width, h:sprite_height};
        this.sprite_geometry = {w:sprite.width/sprite_width, h:sprite.height/sprite_height};
        this.scale = scale
    }

    render(p){
        // Find center of canvas
        let x = (width / 2) - ((this.sprite_size.w * this.scale) / 2);
        let y = (height / 2);

        // Choose proper orientation of ship from sprites
        let r = 360 - Math.floor(p.r)
        r = Math.floor((r % 360) / 10);
        let sx = Math.floor(r % this.sprite_geometry.w);
        sx *= this.sprite_size.w;
        let sy = Math.floor(r / this.sprite_geometry.h);
        sy *= this.sprite_size.h;

        // Place ship
        this.ctx.drawImage(this.sprite, sx, sy, this.sprite_size.w, this.sprite_size.h, x, y, this.sprite_size.w * this.scale, this.sprite_size.h * this.scale);
    }
}

class projectile{
    constructor(ctx, sprite, sprite_width, sprite_height, scale){
        this.ctx = ctx;
        this.sprite = sprite;
        this.sprite_size = {w:sprite_width, h:sprite_height};
        this.scale = scale
        this.projectiles = [];
    }

    add(p){
        this.projectiles.push(
            {
                x: position.x,
                y: position.y,
                r: position.r,
                s: momentum + 15,
                d: 800,
            }
        );
    }

    move(){
        for (let i=0; i<this.projectiles.length; i++){
            this.projectiles[i].y -= Math.cos(Math.PI / 180 * this.projectiles[i].r) * this.projectiles[i].s;
            this.projectiles[i].x += Math.sin(Math.PI / 180 * this.projectiles[i].r) * this.projectiles[i].s;
            this.projectiles[i].d -= this.projectiles[i].s;

            // Wrap
            while (this.projectiles[i].x < 0) this.projectiles[i].x += arena_dimensions.x;
            while (this.projectiles[i].y < 0) this.projectiles[i].y += arena_dimensions.y;
            while (this.projectiles[i].x > arena_dimensions.x) this.projectiles[i].x -= arena_dimensions.x;
            while (this.projectiles[i].y > arena_dimensions.y) this.projectiles[i].y -= arena_dimensions.y;

            if (this.projectiles[i].d <= 0)
                this.projectiles.splice(i,1);
        }
    }

    draw_projectile(p){
        let w = this.sprite_size.w * this.scale;
        let h = this.sprite_size.h * this.scale;
        let dx = p.x - (w/2);
        let dy = p.y - (h/2);
        this.ctx.drawImage(this.sprite, dx, dy, w, h);
    }

    render(p){
        let radians = (Math.PI / 180) * (p.r);
        let cx = width / 2;
        let cy = height / 2;

        for (let projectile of this.projectiles){
            this.ctx.save()
            this.ctx.translate(cx, cy);
            this.ctx.rotate(-radians);
            this.ctx.translate(-p.x, -p.y);
            this.draw_projectile(projectile);
            this.ctx.restore();

            // Draw again if we are straddling a boundary
            this.ctx.save()
            this.ctx.translate(cx, cy);
            this.ctx.rotate(-radians);
            this.ctx.translate(-p.x, -(p.y + arena_dimensions.y));
            this.draw_projectile(projectile);
            this.ctx.restore();

            this.ctx.save()
            this.ctx.translate(cx, cy);
            this.ctx.rotate(-radians);
            this.ctx.translate(-(p.x + arena_dimensions.x), -p.y);
            this.draw_projectile(projectile);
            this.ctx.restore();

            this.ctx.save()
            this.ctx.translate(cx, cy);
            this.ctx.rotate(-radians);
            this.ctx.translate(-(p.x + arena_dimensions.x), -(p.y + arena_dimensions.y));
            this.draw_projectile(projectile);
            this.ctx.restore();
        }
    }
}

class starfield{
    constructor(ctx, max_dimensions, n){
        this.ctx = ctx;
        this.stars = [
            {x:0, y:0, z:.01, c:"#FF0000"},
            {x:125, y:125, z:.01, c:"#0000FF"},
            {x:250, y:250, z:.01, c:"#00FF00"},
        ];

        // Create stars
          for (let i=0; i<n; i++){
            this.stars.push({
                x: Math.random() * max_dimensions.x,
                y: Math.random() * max_dimensions.y,
                z: Math.random(),
                c: "#fff",
            })
          }
    }

    draw_circle(x, y, radius, color){
        this.ctx.fillStyle = color;
        this.ctx.beginPath();
        this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
        this.ctx.fill();
    }

    draw_star(s){
        this.draw_circle(s.x, s.y, (1-s.z) * 5, s.c);
    }

    render(p){
        let radians = (Math.PI / 180) * p.r;
        let cos = Math.cos(radians);
        let sin = Math.sin(radians);

        let cx = width / 2;
        let cy = height / 2;

        document.getElementById("debug").innerHTML = "x:"+p.x+", y:"+p.y+", r:"+p.r+" ("+radians+" rad)";

        for(let star of this.stars){
            /*
            this.ctx.translate(-p.x, -p.y);
            this.ctx.rotate(radians);
            this.ctx.translate(width/2, height/2);
            this.draw_star(star);
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            */

            let x1 = star.x;
            let y1 = star.y;

            // Translate to new origin
            x1 -= (p.x + cx);
            y1 -= (p.y + cy);

            // Wrap around
            while (x1 < 0) x1 += arena_dimensions.x;
            while (y1 < 0) y1 += arena_dimensions.y;
            while (x1 > arena_dimensions.x) x1 -= arena_dimensions.x;
            while (y1 > arena_dimensions.y) y1 -= arena_dimensions.y;

            // Rotate about the center of the screen
            let x2 = ((x1 - cx) * cos) + ((y1 - cy) * sin);
            let y2 = ((y1 - cy) * cos) - ((x1 - cx) * sin);

            // Translate center of rotation back to center of screen
            x2 += cx;
            y2 += cy;

            // Draw star in correct position
            let relative_star = {
                x: x2,
                y: y2,
                z: star.z,
                c: star.c,
            }

            this.draw_star(relative_star);
        }
    }
}

// Keyboard listeners
document.addEventListener('keydown', function(e) {
    //console.log(e);

    // IJKL
    if (e.keyCode == 73) {e.preventDefault(); forward = true};
    if (e.keyCode == 76) {e.preventDefault(); clockwise = true};
    if (e.keyCode == 75) {e.preventDefault(); backward = true};
    if (e.keyCode == 74) {e.preventDefault(); counterclockwise = true};

    //if (e.keyCode == 78) new_game();         // n
    if (e.keyCode == 80) toggle_pause();     // p
    //if (e.keyCode == 46) toggle_debug();     // forward delete
    if (e.keyCode == 32) {e.preventDefault(); fire();} // space
});

document.addEventListener('keyup', function(e) {
    // IJKL
    if (e.keyCode == 73) {e.preventDefault(); forward = false};
    if (e.keyCode == 76) {e.preventDefault(); clockwise = false};
    if (e.keyCode == 75) {e.preventDefault(); backward = false};
    if (e.keyCode == 74) {e.preventDefault(); counterclockwise = false};
});

function toggle_pause(){
    if (paused){
        paused = false;
        main_loop();
    } else {
        paused = true;
    }
}

function fire(){
    player_projectiles.add(position);
}

function resize_canvas(){
    width  = window.innerWidth;
    height = window.innerHeight;
    canvas.width  = width;
    canvas.height = height;
}

function move_position(){
    // Control ship momentum/speed
    if (forward && !backward){
        if (acceleration <= 0)
            acceleration = .15;
        acceleration *= forward_thrust;
        momentum += acceleration;
    }

    if (backward && !forward){
        if (acceleration >= 0)
            acceleration = -.15;
        acceleration *= reverse_thrust;
        momentum += acceleration;
    }

    // set max speed
    if (momentum > max_forward_speed)
        momentum = max_forward_speed;
    if (momentum < max_reverse_speed)
        momentum = max_reverse_speed;

    // Coasting
    if (!backward && !forward){
        acceleration = 0;
        momentum *= deceleration;
        if (momentum < .1 && momentum > -.1)
            momentum = 0;
    }

    // Get x/y components of movement vector
    position.y -= Math.cos(Math.PI / 180 * position.r) * momentum;
    position.x += Math.sin(Math.PI / 180 * position.r) * momentum;

    // Keep position within bounds of arena (wrap)
    while (position.x < 0) position.x += arena_dimensions.x;
    while (position.y < 0) position.y += arena_dimensions.y;
    while (position.x > arena_dimensions.x) position.x -= arena_dimensions.x;
    while (position.y > arena_dimensions.y) position.y -= arena_dimensions.y;

    // Rotational momentum
    if (clockwise && !counterclockwise){
        if (rot_accel <= 0)
            rot_accel = .15;
        rot_accel *= rotational_thrust;
        rot_momentum += rot_accel;
    }
    if (counterclockwise && !clockwise){
        if (rot_accel >= 0)
            rot_accel = -.15;
        rot_accel *= rotational_thrust;
        rot_momentum += rot_accel;
    }

    if (rot_momentum > max_rotational_speed)
        rot_momentum = max_rotational_speed;
    if (rot_momentum < -1 * max_rotational_speed)
        rot_momentum = -1 * max_rotational_speed;

    if (!counterclockwise && !clockwise){
        rot_accel = 0;
        rot_momentum *= deceleration;
        if (rot_momentum < .1 && rot_momentum > -.1)
            rot_momentum = 0;
    }

    position.r += rot_momentum;

    // loop r so it's never out of range
    while (position.r < 0)   position.r += 360;
    while (position.r > 360) position.r -= 360;
}

// Canvas
let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");
let width = canvas.width;
let height = canvas.height;

// Classes
let stars;
let player;
let projectiles;

// Movement Stuff
let forward = false;
let backward = false;
let clockwise = false;
let counterclockwise = false;
let position = {};
let movement = {};
let acceleration = 0;
let momentum = 0;
let rot_accel = 0;
let rot_momentum = 0;

let forward_thrust = 1.1;
let reverse_thrust = 1.01;
let rotational_thrust = 1.01;
let deceleration = .95;
let max_forward_speed = 20;
let max_rotational_speed = 1.5;
let max_reverse_speed = -10;

// Sprites
const sprite_player = new Image();
sprite_player.src = "sprites/main_ship_512.png";

const sprite_projectile = new Image();
sprite_projectile.src = "sprites/projectile.png";

// Game Stuff
let arena_dimensions = {x:5000, y:5000};
let timer;
let tick_interval = 10;
let paused;

function main_loop(){
    // Clear canvas
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, width, height);

    // Move position
    move_position();
    player_projectiles.move();

    // Draw stars
    stars.render(position);

    // Draw projectiles
    player_projectiles.render(position);

    // Draw ship(s)
    player.render(position);

    // Setup next looop
    if (!paused)
        timer = setTimeout(() => main_loop(), tick_interval);
}

function first_load(){
    // Resize canvas
    resize_canvas();

    // Create star field
    stars = new starfield(ctx, arena_dimensions, 500)

    // Create ship
    player = new ship(ctx, sprite_player, 512, 512, .5);

    // Clear projectiles
    player_projectiles = new projectile(ctx, sprite_projectile, 100, 100, .35);

    // Set default position
    position.x = arena_dimensions.x / 2;
    position.y = arena_dimensions.y / 2;
    position.r = 0; // Pointing up?

    // Start looping
    main_loop();
}


  </script>
</html>
