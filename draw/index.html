<html>
  <head>
    <title>Test</title>
    <meta name="viewport" content="user-scalable=no" />
    <style>
canvas{
    border: 0px solid black;
    touch-action:manipulation;
    position:absolute;
    top:0;
    left:0;
}
body{
    margin: 0px;
}
#controls{
    position:absolute;
    top: 10px;
    left: 10px;
}
    </style>
  </head>
  <body onload="main();" onresize="resize();">
    <canvas id="canvas" width="512" height="512"></canvas>
    <div id="controls">
      Decay: <input id="decay" type="range" min="0" max="100" value="50" onchange="update_decay();"></input><br>
      Diameter: <input id="diameter" type="range" min="0" max="100" value="50"></input><br>
      Coordinates: <span id="coords"></span>
    </div>
  </body>
<script>

// Globals!
var MOUSEDOWN = false;
const canvas = document.querySelector('canvas')
var ctx = canvas.getContext('2d');
var timeout = null;
var decay = .05;
var last_coords;

// Coordinate finding functions
function getTouchPosition(overlay, event){
    if (!e)
        var e = event;

    var x = null;
    var y = null;

    if(e.touches) {
        if (e.touches.length == 1) { // Only deal with one finger
            var touch = e.touches[0]; // Get the information for finger #1
            x = touch.pageX-touch.target.offsetLeft;
            y = touch.pageY-touch.target.offsetTop - (tile_size / 2); // Adjust y because apple messes things up!
        }
    }

    return {x:x, y:y};
}

function getCursorPosition(canvas, event){
    // Determine where clicked
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    if (last_coords == null)
	last_coords = {x:x, y:y};

    // Draw between last position and current position
    draw_line(ctx, last_coords.x, last_coords.y, x, y);

    // Draw our final actual location
    //draw_gradient(ctx, x, y);
    document.getElementById("coords").innerHTML = x + ", " + y;

    last_coords = {x:x, y:y};
}

// Touch Listeners
canvas.addEventListener('touchstart', function(e){
    MOUSEDOWN = true;
    getTouchPosition(canvas, e);
    e.preventDefault();
}, false);

canvas.addEventListener('touchmove', function(e){
    if (MOUSEDOWN == true)
	getTouchPosition(canvas, e);
    e.preventDefault();
}, false);

canvas.addEventListener('touchend', function(e){
    MOUSEDOWN = false;
    e.preventDefault();
}, false);

// Mouse Listeners
canvas.addEventListener('mousedown', function(e){
    MOUSEDOWN = true;
    getCursorPosition(canvas, e);
});

canvas.addEventListener('mousemove', function(e){
    if (MOUSEDOWN == true)
	getCursorPosition(canvas, e);
});

canvas.addEventListener('mouseup', function(e){
    MOUSEDOWN = false;
    last_coords = null;
});

function draw_line(ctx, x1, y1, x2, y2){
    let r = document.getElementById("diameter").value/2;

    let dx = x2 - x1;
    let dy = y2 - y1;
    let distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

    for (let i=1; i<distance; i+=1){
	let p = i / distance;
	draw_gradient(ctx, x1+(dx * p), y1+(dy * p));
    }
    
    /*
    // solid line
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = r;
    ctx.stroke();
    */
}

function draw_gradient(ctx, x, y){
    let r = document.getElementById("diameter").value/2;
    
    let innerRadius = 0;
    let outerRadius = r;

    var gradient = ctx.createRadialGradient(x, y, innerRadius, x, y, outerRadius);
    gradient.addColorStop(0, "rgba(0,0,0,1)");
    gradient.addColorStop(.5, "rgba(0,0,0,.1)");
    gradient.addColorStop(1, "rgba(0,0,0,0)");
    //gradient.addColorStop(0, "rgba(255,255,255,1)");
    //gradient.addColorStop(1, "rgba(255,255,255,0)");

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.arc(x, y, r, 0, 2*Math.PI);
    ctx.fillStyle = gradient;
    ctx.fill();
}

function slowly_fade() {
    //console.log(decay);
    //ctx.fillStyle = "rgba(255,255,255,"+decay+")";
    //ctx.fillStyle = "rgba(0,0,0,"+decay+")";
    //ctx.fillStyle = "rgba(0,0,0,.05)";
    //ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Test; try increasing value of everysingle pixel
    var img = ctx.getImageData(0, 0, canvas.width, canvas.height);
    var pix = img.data;
    for (var i=0; i<pix.length; i+=1){
	pix[i] = pix[i] + 1 > 255 ? 255: pix[i] + (200 * decay);
    }
    ctx.putImageData(img, 0, 0);

    if (MOUSEDOWN)
	draw_gradient(ctx, last_coords.x, last_coords.y);
    
    timeout = setTimeout(() => slowly_fade(), 10);
    //timeout = setTimeout(() => slowly_fade(), decay);
}

function resize(){
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
}

function update_decay(){
    let value = document.getElementById("decay").value;
    //decay = value;
    decay = value/1000;
}


function main(){
resize();
    slowly_fade();
}


</script>
</html>
