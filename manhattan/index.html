<!DOCTYPE html>

<html>
  <head>
    <title>Manhattan Distance</title>
    <meta charset="utf-8"/>
    <style>
      body {
          background: lightgrey;
          font-family: sans-serif;
      }
      #content {
          width: 512px;
          margin: auto;
          background: white;
          padding: 20px;
          border-radius: 20px;
      }

      input {
          width: 50px;
          margin-right: 20px;
      }
    </style>
  </head>

  <body onload="first_run();">
    <div id="content">
      <h1>Manhattan Distance</h1>
      <p>Find the number of cells within the specified range of specific (positive) cells.</p>

      <div id="input">
        <canvas id="canvas" width="512" height="512"/>
      </div>

      <div id="settings">
        <h2>Settings</h2>
        Width: <input id="width" value="11"></input>
        Height: <input id="height" value="11"></input>
        Distance: <input id="distance" value="3"></input>
        <button id="update" onclick="update_settings()">Update</button>
      </div>

      <div id="output_wrapper">
        <h2>Results</h2>
        <div id="output">
        </div>
      </div>
    </div>

  </body>

  <script>

    // Global Variables
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    let array = [[-1]];
    let square_size = 0;
    let distance = 3;

    let mousedown = false;
    let highlight;
    let debug = false;

    // Mouse Listeners and interactions
    canvas.addEventListener('mousedown',  () => mouse_down(), false);
    canvas.addEventListener('mousemove',  () => mouse_move(), false);
    canvas.addEventListener('mouseup',    () => mouse_up(), false);
    canvas.addEventListener('mouseleave', () => mouse_leave(), false);

    function get_cursor_position(event) {
        // Determine where clicked
        const rect = this.canvas.getBoundingClientRect()
        const x = event.clientX - rect.left
        const y = event.clientY - rect.top

        var sx = Math.floor(x / square_size);
        var sy = Math.floor(y / square_size);

        // Ensure we don't toggle anything outside of the array boundaries
        if (sx >= array[0].length || sy >= array.length)
            return null;

        // Return X, Y coordinates
        return {x:sx, y:sy};
    }

    function mouse_down() {
	mousedown = true;
        highlight = get_cursor_position(event);
	update_visual();
    }

    function mouse_move() {
        if (mousedown) {
            highlight = get_cursor_position(event);
            update_visual();
        }
    }

    function mouse_up() {
	if (mousedown) {
	    mousedown = false;
            highlight = null;
	    toggle_position(get_cursor_position(event));
            update_visual();
	}
    }

    function mouse_leave() {
	mousedown = false;
	highlight = null;
        update_visual();
    }

    function toggle_position(c) {
        if (c != null) {
	    if (array[c.y][c.x] > 0)
                array[c.y][c.x] = -1;
            else {
                let n = [];
                for (y=0; y<array.length; y++)
                    for (x=0; x<array[0].length; x++)
                        if (array[y][x] > 0)
                            n.push(array[y][x]);

                // Sort the neighborhood numbers
                n.sort(function(a, b){return a - b});

                // Find missing neighborhood and use it
                for (let i=0; i<n.length; i++) {
                    if (n[i] != i+1) {
                        array[c.y][c.x] = i+1;
                        return;
                    }
                }

                // Everything is sequential; make a new number!
                array[c.y][c.x] = n.length + 1;
            }
        }
    }

    // UI functions for Input and Output
    function update_settings() {
        let width = Number(document.getElementById("width").value);
        let height = Number(document.getElementById("height").value);
        distance = Number(document.getElementById("distance").value);

        let new_array = [];
        // Adjust array size
        for (let y=0; y<height; y++){
            let new_row = [];
            for (let x=0; x<width; x++){
                if (y < array.length && x < array[y].length)
                    new_row.push(array[y][x]);
                else
                    new_row.push(-1);
            }
            new_array.push(new_row);
        }
        array = new_array;

        let canvas_width = canvas.width;
        let canvas_height = canvas.height;

        square_size = Math.floor(Math.min(canvas_width/width, canvas_height/height));

        update_visual();
    }

    function update_output(n, m, mm) {
        let output = document.getElementById("output");
        output.innerHTML = "";

        // Show count of neighborhoods
        let neighborhoods = document.createElement("p");
        neighborhoods.innerHTML = "Neighborhoods: " + n;
        output.appendChild(neighborhoods);


        // Show the count of members in a neighborhood
        let members = document.createElement("p");
        members.innerHTML = "Neighborhood Members: " + m;
        output.appendChild(members);

        // Show breakdown of members belonging to multiple neighborhoods
        for (let n in mm) {
            let t = document.createElement("p");
            t.innerHTML = "Members of " + n + " neighborhoods: " + mm[n];
            output.appendChild(t);
        }

        // Output the resulting array just because we can
        if (debug == true) {
            let output_array = document.createElement("pre");
            output_array.innerHTML = "[<br>"
            for (let row of array)
                output_array.innerHTML += " " + JSON.stringify(row) + ",<br>";
            output_array.innerHTML += "]<br>"
            output.appendChild(output_array);
        }
    }

    // Functions for visualization
    function draw_square(x, y, h, l, a) {
	ctx.fillStyle = "hsla("+h+",100%,"+l+"%,"+a+")";
	ctx.fillRect(x*square_size, y*square_size, square_size, square_size);
    }

    function number_to_hue(n) {
        return ((n-1) * 50) % 360;
    }

    function update_visual() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let width = array[0].length;
        let height = array.length;

        let neighborhoods = 0;
        let members = 0;
        let multi_members = {};

        for (let y=0; y<height; y++){
            for (let x=0; x<width; x++){
                // Positive Numbers
                if (array[y][x] > 0) {
                    neighborhoods++;
                    members++;

                    draw_square(x, y, number_to_hue(array[y][x]), 50, 1);
                } else {
                    // Negative Numbers
                    let m = manhattan_distance(x, y);

                    if (m.length > 0) {
                        members++;

                        // Shade the colors so we can see which one belong to multiple neighborhoods
                        for (n of m) {
                            draw_square(x, y, number_to_hue(n), 50, .25);
                        }
                    }

                    if (m.length > 1) {
                        if (multi_members[m.length])
                            multi_members[m.length]++;
                        else
                            multi_members[m.length] = 1;
                    }

                }

                // Outline cell
                ctx.beginPath();
                ctx.lineWidth = "2";
                ctx.strokeStyle = "black";
                ctx.rect(x*square_size, y*square_size, square_size, square_size);
                ctx.stroke();

            }
        }

        if (highlight != null) {
            ctx.beginPath();
            ctx.lineWidth = "2";
            ctx.strokeStyle = "red";
            ctx.rect(highlight.x*square_size, highlight.y*square_size, square_size, square_size);
            ctx.stroke();
        }

        update_output(neighborhoods, members, multi_members);
    }

    // Manhattan Distance function for any given X/Y coordinate
    function manhattan_distance(x, y) {
        let neighborhoods = [];

        // Find valid distance coordiantes
        for (let dx=distance * -1; dx<=distance; dx++) {
            for (let dy=distance * -1; dy<=distance; dy++) {
                let td = Math.abs(dx) + Math.abs(dy);
                if (td <= distance) {
                    // Make sure these coords are within bounds of array
                    if (x + dx >= 0 && x + dx < array[0].length) {
                        if (y + dy >= 0 && y + dy < array.length) {
                            // Look for positive values
                            if (array [y + dy][x + dx] > 0) {
                                neighborhoods.push(array [y + dy][x + dx]);
                            }
                        }
                    }
                }
            }
        }
        return neighborhoods;
    }

    // Set up everything when we first load
    function first_run() {
        update_settings();
    }

  </script>
</html>
